<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER STACK: TOURNAMENT</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --card-bg: #161b22;
            --highlight: #58a6ff;
            --danger: #da3633;
            --success: #238636;
            --warning: #d29922;
            --text-main: #c9d1d9;
            --border: #30363d;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 { margin-bottom: 5px; text-shadow: 0 0 10px var(--highlight); }
        .subtitle { font-size: 12px; color: #8b949e; margin-bottom: 20px; }
        
        /* --- SCREENS --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.98);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
        }
        .hidden { display: none !important; }

        .game-container {
            display: flex; flex-direction: column; gap: 20px;
            width: 100%; max-width: 1000px;
        }

        /* --- AREAS --- */
        .opponent-area { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .player-area {
            background: #0d1117; border: 2px solid var(--highlight);
            padding: 20px; border-radius: 8px; min-height: 280px;
            position: relative;
        }
        .turn-indicator {
            position: absolute; top: -15px; left: 20px; 
            background: var(--bg-color); color: var(--highlight); 
            border: 2px solid var(--highlight); padding: 5px 15px;
            font-weight: bold; font-size: 14px; border-radius: 4px;
        }
        
        .info-panel {
            display: flex; justify-content: space-between; background: #21262d;
            padding: 10px; border-radius: 4px; margin-bottom: 10px; margin-top: 10px;
        }

        /* --- CARDS --- */
        .card-zone {
            display: flex; gap: 10px; min-height: 130px; padding: 10px;
            background: rgba(255,255,255,0.05); border-radius: 4px;
            margin-bottom: 10px; align-items: center; overflow-x: auto;
        }
        .card {
            background: var(--card-bg); border: 1px solid var(--border);
            border-radius: 6px; width: 100px; height: 140px;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 5px; font-size: 11px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s; position: relative; flex-shrink: 0;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--highlight); }
        .card.selected { border: 2px solid var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        .card.burning { border: 2px solid var(--danger); opacity: 0.8; } 
        .card.burning::after {
            content: "ðŸ”¥"; position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); font-size: 24px;
        }

        .card-side { padding: 4px; border-radius: 3px; text-align: center; background: #21262d; flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .card-side.active { background: #1f6feb; color: white; }
        .card-side:hover { background: #30363d; }
        
        .side-title { font-weight: bold; display: block; margin-bottom: 2px; }
        .side-stats { font-size: 10px; color: #8b949e; }
        .card-side.active .side-stats { color: #e1e4e8; }

        /* Types */
        .type-red { border-top: 3px solid #ff4444; }
        .type-blue { border-top: 3px solid #4444ff; }
        .type-green { border-top: 3px solid #44ff44; }
        .type-yellow { border-top: 3px solid #ffff44; }
        .type-purple { border-top: 3px solid #aa44ff; }
        .type-wild { border-top: 3px solid white; }
        .type-action { border-top: 3px solid orange; }
        .type-gray { border-top: 3px solid #555; }

        /* --- CONTROLS --- */
        .controls { display: flex; justify-content: center; gap: 20px; margin: 20px 0; align-items: center; }
        .btn-group { display: flex; gap: 10px; }
        button {
            padding: 15px 25px; font-size: 16px; font-weight: bold; color: white;
            border: none; border-radius: 4px; cursor: pointer; font-family: inherit;
        }
        .btn-play { background: var(--success); }
        .btn-play:disabled { background: #30363d; opacity: 0.5; cursor: not-allowed; }
        .btn-pass { background: var(--warning); color: #000; }
        .btn-discard { background: #30363d; color: #fff; border: 1px solid #8b949e; }
        
        .overclock-panel {
            display: flex; flex-direction: column; align-items: center;
            background: #331; padding: 10px; border: 1px solid #774;
            border-radius: 4px; min-width: 120px;
        }

        .dice-box {
            width: 60px; height: 60px; background: white; color: black;
            font-size: 30px; font-weight: bold; display: flex;
            align-items: center; justify-content: center;
            border-radius: 8px; box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        /* --- LOG & MODALS --- */
        #game-log {
            height: 150px; overflow-y: auto; background: #000;
            border: 1px solid var(--border); padding: 10px;
            font-size: 12px; font-family: monospace; color: #0f0;
        }
        .log-turn { color: var(--highlight); border-bottom: 1px solid #333; margin-top: 5px; }
        .log-fail { color: var(--danger); }
        .log-success { color: var(--success); }
        .log-pass { color: var(--warning); }
        .log-win { color: #d29922; font-weight: bold; }

        /* Modal for Discard */
        #discard-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 50;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-content {
            background: var(--bg-color); border: 2px solid var(--border);
            padding: 20px; width: 90%; max-width: 900px; max-height: 80vh;
            overflow-y: auto; border-radius: 8px;
        }
        .modal-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }

        /* --- HUD --- */
        .player-hud { width: 220px; background: #161b22; padding: 10px; border: 1px solid #30363d; border-radius: 4px; margin-bottom:5px; }
        .hud-header { font-weight: bold; border-bottom: 1px solid #30363d; padding-bottom: 5px; margin-bottom: 5px; display: flex; justify-content: space-between;}
        .hud-stats { display: flex; gap: 10px; font-size: 11px; margin-bottom: 5px; }
        .mini-card-container { display: inline-flex; flex-direction: column; align-items: center; margin: 2px; }
        .mini-card { 
            display: grid; place-items: center; width: 18px; height: 18px; 
            font-size: 10px; border-radius: 3px; border: 2px solid #444; font-weight: bold;
        }
        .mini-val { font-size: 9px; color: #888; margin-top: 2px; }
        
        .selection-group { margin: 10px 0; text-align: center; }
        .sel-btn { background: #21262d; border: 1px solid #30363d; color: white; padding: 10px 20px; margin: 0 5px; }
        .sel-btn.active { background: var(--highlight); border-color: var(--highlight); }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 40px; color: var(--highlight);">CYBER STACK</h1>
        <div style="color: var(--warning); font-size: 14px; margin-bottom: 20px;">// TOURNAMENT EDITION (3 ROUNDS) //</div>
        
        <div class="selection-group">
            <div>HUMAN PLAYERS</div>
            <button class="sel-btn active" onclick="setSetup('p', 1)">1</button>
            <button class="sel-btn" onclick="setSetup('p', 2)">2</button>
            <button class="sel-btn" onclick="setSetup('p', 3)">3</button>
            <button class="sel-btn" onclick="setSetup('p', 4)">4</button>
        </div>

        <div class="selection-group">
            <div>CPU OPPONENTS</div>
            <button class="sel-btn" onclick="setSetup('b', 0)">0</button>
            <button class="sel-btn active" onclick="setSetup('b', 1)">1</button>
            <button class="sel-btn" onclick="setSetup('b', 2)">2</button>
            <button class="sel-btn" onclick="setSetup('b', 3)">3</button>
        </div>

        <button class="btn-play" style="margin-top:20px; width: 200px;" onclick="startGame()">INITIALIZE</button>
    </div>

    <div id="discard-modal" class="hidden">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2>DISCARD PILE (READ ONLY)</h2>
                <button class="btn-pass" onclick="toggleDiscard()">CLOSE</button>
            </div>
            <div id="discard-grid" class="modal-grid"></div>
        </div>
    </div>

    <h1>CYBER STACK</h1>
    <div class="subtitle">// ROUND <span id="game-round">1</span> OF 3 // TRIGGER: 5 COLORS //</div>

    <div id="game-root" class="game-container hidden">
        <div id="opponents" class="opponent-area"></div>

        <div class="controls">
            <div id="dice-display" class="dice-box">?</div>
            
            <div class="overclock-panel">
                <div style="font-size: 12px; margin-bottom: 5px; color: #fe9;">OVERCLOCK</div>
                <div style="font-size: 10px; color: #888;">Right-Click Hand</div>
                <div id="bonus-display" style="font-size: 18px; font-weight: bold; color: #fe9;">+0</div>
            </div>

            <div class="btn-group">
                <button id="btn-roll" class="btn-play" onclick="commitTurn()">CONFIRM</button>
                <button id="btn-pass" class="btn-pass" onclick="passTurn()">REBOOT (PASS)</button>
                <button id="btn-disc" class="btn-discard" onclick="toggleDiscard()">DISCARD (0)</button>
            </div>
            
            <div style="text-align: left; font-size: 12px;">
                <div>TURN: <span id="turn-display">1</span></div>
                <div>PHASE: <span id="phase-display" style="color: var(--highlight)">PLANNING</span></div>
            </div>
        </div>

        <div class="player-area">
            <div id="active-player-name" class="turn-indicator">PLAYER 1</div>

            <div class="info-panel">
                <div>
                    <strong>CURRENT SCORE:</strong> 
                    <span id="player-score" style="color: var(--success); margin-left: 10px; font-size: 1.2em;">0 VP</span>
                    <span id="total-score-display" style="color: #888; font-size: 0.8em; margin-left:10px;">(Total: 0)</span>
                </div>
                <div>
                    <span id="hand-count" style="color: #fff;">Hand: 0/5</span> | 
                    <span id="colors-status" style="color: var(--highlight);">Colors: 0/5</span>
                </div>
            </div>

            <div style="font-size: 12px; color: #888; margin-bottom: 5px;">
                SCORE PILE (Collect 5 Distinct Colors to End Round):
            </div>
            <div id="player-score-pile" class="card-zone"></div>

            <div style="font-size: 12px; color: #888; margin-bottom: 5px;">
                HAND (Ammo) | Right-Click to Burn (+1 Roll)
            </div>
            <div id="player-hand" class="card-zone"></div>
        </div>

        <div id="game-log"></div>
    </div>

<script>
/* --- CONFIG --- */
const COLORS = ["Red", "Blue", "Green", "Yellow", "Purple"];
const STARTING_HAND = 3;
const MAX_HAND = 5;
const TRIGGER_COLORS = 5; 
const TOTAL_ROUNDS = 3;

/* --- STATE --- */
let deck = [];
let discardPile = [];
let players = [];
let turnCount = 1;
let currentRound = 1;
let activePlayerIdx = 0; // Index of player currently deciding
let gameOver = false;

// Setup vars
let setupP = 1;
let setupB = 1;

/* --- CLASSES --- */
class Card {
    constructor(s1, s2) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.sides = [s1, s2];
        this.selectedSide = 0; 
        this.isBurning = false; 
    }
}

class Player {
    constructor(name, isBot) {
        this.name = name;
        this.isBot = isBot;
        this.hand = [];
        this.scorePile = [];
        this.cache = [];
        this.passed = false;
        this.selection = null; // {card, sideIndex}
        this.bonus = 0;
        this.totalScore = 0; // Across 3 rounds
    }

    getRoundScore() {
        let s = 0;
        this.scorePile.forEach(c => s += c.sides[c.selectedSide].value);
        this.cache.forEach(c => s += c.sides[c.selectedSide].value);
        return s;
    }

    getUniqueColors() {
        let colorSet = new Set();
        let wildCount = 0;
        this.scorePile.forEach(c => {
            let s = c.sides[c.selectedSide];
            if(s.type === 'Color') colorSet.add(s.name);
            if(s.type === 'Wild') wildCount++;
        });
        return Math.min(TRIGGER_COLORS, colorSet.size + wildCount); 
    }

    resetForRound() {
        this.hand = [];
        this.scorePile = [];
        this.cache = [];
        this.passed = false;
        this.selection = null;
        this.bonus = 0;
    }
}

/* --- SETUP & INIT --- */
function setSetup(type, val) {
    if(type === 'p') setupP = val;
    if(type === 'b') setupB = val;
    
    // Update UI buttons
    let group = type === 'p' ? document.querySelectorAll('.selection-group')[0] : document.querySelectorAll('.selection-group')[1];
    Array.from(group.querySelectorAll('.sel-btn')).forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-root').classList.remove('hidden');

    players = [];
    for(let i=1; i<=setupP; i++) players.push(new Player(`PLAYER ${i}`, false));
    for(let i=1; i<=setupB; i++) players.push(new Player(`CPU ${i}`, true));

    currentRound = 1;
    startNewRound();
}

function startNewRound() {
    turnCount = 1;
    deck = generateDeck();
    discardPile = [];
    
    players.forEach(p => {
        p.resetForRound();
        drawCards(p, STARTING_HAND);
    });

    log(`=== STARTING ROUND ${currentRound} OF ${TOTAL_ROUNDS} ===`, true);
    document.getElementById('game-round').innerText = currentRound;
    
    activePlayerIdx = 0;
    updateUI();
}

function generateDeck() {
    let d = [];
    // Colors
    for(let i=0; i<COLORS.length; i++) {
        for(let j=i+1; j<COLORS.length; j++) {
            let c1 = COLORS[i], c2 = COLORS[j];
            d.push(new Card({name:c1, type:'Color', target:5, value:4}, {name:c2, type:'Color', target:3, value:1}));
            d.push(new Card({name:c1, type:'Color', target:4, value:3}, {name:c2, type:'Color', target:4, value:3}));
            d.push(new Card({name:c1, type:'Color', target:3, value:2}, {name:c2, type:'Color', target:5, value:4}));
        }
    }
    COLORS.forEach(c => {
        d.push(new Card({name:'Wild', type:'Wild', target:6, value:5}, {name:c, type:'Color', target:2, value:1}));
    });
    for(let i=0; i<5; i++) {
        d.push(new Card({name:'Server Node', type:'Action', effect:'Data Surge', target:4, value:0}, {name:'Data Cache', type:'Point', target:3, value:2}));
    }
    for(let i=0; i<4; i++) {
        d.push(new Card({name:'Hack', type:'Action', effect:'Sabotage', target:4, value:0}, {name:'Scavenge', type:'Action', effect:'Scavenge', target:3, value:0}));
    }
    return shuffle(d);
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function drawCards(p, count) {
    for(let i=0; i<count; i++) {
        if(deck.length === 0 && discardPile.length > 0) {
            deck = shuffle([...discardPile]);
            discardPile = [];
        }
        if(deck.length > 0) {
            if(p.hand.length < MAX_HAND) {
                p.hand.push(deck.pop());
            } else {
                discardPile.push(deck.pop());
            }
        }
    }
}

/* --- PLAYER ACTIONS --- */
function passTurn() {
    let p = players[activePlayerIdx];
    p.passed = true;
    p.selection = null;
    p.hand.forEach(c => c.isBurning = false);
    p.bonus = 0;
    log(`${p.name} REBOOTS (Pass).`);
    advanceQueue();
}

function commitTurn() {
    let p = players[activePlayerIdx];
    if (!p.selection) {
        alert("Select a card to play first!");
        return;
    }
    
    // Lock in Burning
    p.bonus = 0;
    let finalHand = [];
    p.hand.forEach(c => {
        if (c.isBurning) {
            discardPile.push(c);
            p.bonus++;
        } else {
            finalHand.push(c);
        }
    });
    p.hand = finalHand;

    // Safety: check if selection still exists (wasn't burned)
    if (!p.hand.includes(p.selection.card)) {
        p.passed = true;
        p.selection = null;
    }

    advanceQueue();
}

function advanceQueue() {
    activePlayerIdx++;
    
    // Find next human
    if(activePlayerIdx < players.length && !players[activePlayerIdx].isBot) {
        // Next human's turn
        updateUI();
    } else {
        // All humans done. Process Bots then Execute
        processBots();
        executeRound();
    }
}

/* --- EXECUTION PHASE --- */
function processBots() {
    players.filter(p => p.isBot).forEach(bot => {
        bot.bonus = 0;
        bot.passed = false;
        bot.selection = null;

        if (bot.hand.length === 0) { bot.passed = true; return; }

        // Simple Bot Logic
        let best = null;
        let bestScore = -99;

        bot.hand.forEach((c, idx) => {
            c.sides.forEach((s, sIdx) => {
                let score = s.value + (6 - s.target); // Value + Ease
                if(s.type === 'Color' && !hasColor(bot, s.name)) score += 5;
                if(score > bestScore) { bestScore = score; best = {card:c, side:sIdx}; }
            });
        });

        if(best) {
            bot.selection = {card: best.card, sideIndex: best.side};
            // Occasional burn
            if(best.card.sides[best.side].target >= 5 && bot.hand.length > 3) {
                let burn = bot.hand.find(c => c !== best.card);
                if(burn) {
                    bot.hand = bot.hand.filter(x => x!==burn);
                    discardPile.push(burn);
                    bot.bonus = 1;
                }
            }
        } else {
            bot.passed = true;
        }
    });
}

function hasColor(p, name) {
    return p.scorePile.some(c => c.sides[c.selectedSide].name === name);
}

function executeRound() {
    let baseRoll = Math.floor(Math.random() * 6) + 1;
    document.getElementById('dice-display').innerText = baseRoll;
    log(`--- TURN ${turnCount} | ROLL: [ ${baseRoll} ] ---`, true);

    players.forEach(p => resolvePlayer(p, baseRoll));

    // Check Trigger
    let roundEnded = players.some(p => p.getUniqueColors() >= TRIGGER_COLORS);

    if(roundEnded) {
        endRound();
    } else {
        // Cleanup & Next Turn
        players.forEach(p => {
            drawCards(p, 1);
            p.selection = null;
            p.passed = false;
            p.bonus = 0;
            p.hand.forEach(c => c.isBurning = false);
        });
        activePlayerIdx = 0;
        turnCount++;
        updateUI();
    }
}

function resolvePlayer(p, baseRoll) {
    if(p.passed || !p.selection) return;

    let card = p.selection.card;
    let sIdx = p.selection.sideIndex;
    let side = card.sides[sIdx];
    let total = baseRoll + p.bonus;

    // Remove played card from hand
    let hIdx = p.hand.indexOf(card);
    if(hIdx > -1) p.hand.splice(hIdx, 1);

    if(total >= side.target) {
        log(`${p.name} Success: ${side.name} (${side.value} VP)`, false, 'success');
        
        card.selectedSide = sIdx;
        if (side.effect === 'Data Surge') {
            drawCards(p, 2);
            log(`> Data Surge! +2 Cards`);
            discardPile.push(card);
        } else if (side.effect === 'Sabotage') {
            handleSabotage(p);
            discardPile.push(card);
        } else if (side.effect === 'Scavenge') {
            if(discardPile.length) p.hand.push(discardPile.pop());
            discardPile.push(card);
        } else if (side.type === 'Point') {
            p.cache.push(card);
        } else {
            p.scorePile.push(card);
        }
    } else {
        log(`${p.name} Fails ${side.name} (Rolled ${total})`, false, 'fail');
        discardPile.push(card);
    }
}

function handleSabotage(attacker) {
    let targets = players.filter(pl => pl !== attacker && pl.scorePile.length > 0);
    if(targets.length) {
        let victim = targets[Math.floor(Math.random()*targets.length)];
        let stolen = victim.scorePile.pop();
        attacker.scorePile.push(stolen);
        log(`> Stole ${stolen.sides[stolen.selectedSide].name} from ${victim.name}!`);
    }
}

function endRound() {
    let msg = `ROUND ${currentRound} COMPLETE! SCORES:\n`;
    players.forEach(p => {
        let s = p.getRoundScore();
        p.totalScore += s;
        msg += `${p.name}: ${s} (Total: ${p.totalScore})\n`;
    });
    alert(msg);

    if (currentRound < TOTAL_ROUNDS) {
        currentRound++;
        startNewRound();
    } else {
        endGame();
    }
}

function endGame() {
    let winner = players.sort((a,b) => b.totalScore - a.totalScore)[0];
    alert(`TOURNAMENT OVER!\n\nWINNER: ${winner.name}\nFINAL SCORE: ${winner.totalScore}`);
    location.reload();
}

/* --- UI --- */
function selectSide(cIdx, sIdx) {
    let p = players[activePlayerIdx];
    let card = p.hand[cIdx];
    if(card.isBurning) return; 
    p.selection = {card: card, sideIndex: sIdx};
    updateUI();
}

function toggleBurn(cIdx) {
    let p = players[activePlayerIdx];
    let card = p.hand[cIdx];
    if(p.selection && p.selection.card === card) return; 
    card.isBurning = !card.isBurning;
    p.bonus = p.hand.filter(c => c.isBurning).length;
    updateUI();
}

function toggleDiscard() {
    let modal = document.getElementById('discard-modal');
    if(modal.classList.contains('hidden')) {
        modal.classList.remove('hidden');
        let grid = document.getElementById('discard-grid');
        grid.innerHTML = '';
        discardPile.forEach(c => {
            // Full card, non-interactive
            let d = createCardElement(c, true, -1, true);
            d.style.cursor = 'default';
            d.style.pointerEvents = 'none'; // Disable clicks
            grid.appendChild(d);
        });
    } else {
        modal.classList.add('hidden');
    }
}

function updateUI() {
    let p = players[activePlayerIdx];
    
    // Header Info
    document.getElementById('active-player-name').innerText = `${p.name}'S TURN`;
    document.getElementById('turn-display').innerText = turnCount;
    document.getElementById('btn-roll').innerText = (activePlayerIdx < players.length - players.filter(x=>x.isBot).length - 1) ? "NEXT PLAYER" : "EXECUTE ROUND";

    // Stats
    document.getElementById('player-score').innerText = `${p.getRoundScore()} VP`;
    document.getElementById('total-score-display').innerText = `(Total: ${p.totalScore})`;
    document.getElementById('colors-status').innerText = `Colors: ${p.getUniqueColors()}/${TRIGGER_COLORS}`;
    document.getElementById('bonus-display').innerText = `+${p.bonus}`;
    document.getElementById('hand-count').innerText = `Hand: ${p.hand.length}/${MAX_HAND}`;
    document.getElementById('btn-disc').innerText = `DISCARD (${discardPile.length})`;

    // Hand
    let handDiv = document.getElementById('player-hand');
    handDiv.innerHTML = '';
    p.hand.forEach((card, idx) => {
        let el = createCardElement(card, true, idx);
        el.oncontextmenu = (e) => { e.preventDefault(); toggleBurn(idx); };
        handDiv.appendChild(el);
    });

    // Score Pile
    let pileDiv = document.getElementById('player-score-pile');
    pileDiv.innerHTML = '';
    p.scorePile.forEach(card => pileDiv.appendChild(createCardElement(card, false)));

    // Opponents HUD
    let oppDiv = document.getElementById('opponents');
    oppDiv.innerHTML = '';
    players.forEach((opp, i) => {
        if(i !== activePlayerIdx) {
            oppDiv.appendChild(createOpponentHUD(opp));
        }
    });

    document.getElementById('btn-roll').disabled = !p.selection;
}

function createCardElement(card, interactable, index, isDiscard = false) {
    let el = document.createElement('div');
    el.className = 'card';
    if(card.isBurning) el.classList.add('burning');
    
    let s0 = card.sides[0];
    let s1 = card.sides[1];
    
    // Show Full Split Card (Hand or Discard)
    if (interactable || isDiscard) {
        el.innerHTML = `
            <div class="card-side type-${getTypeClass(s0.type)}" ${!isDiscard ? `onclick="selectSide(${index}, 0)"` : ''}>
                <span class="side-title">${s0.name}</span>
                <span class="side-stats">T${s0.target} | ${getValStr(s0)}</span>
            </div>
            <div style="text-align:center; color:#444; font-size:9px;">- OR -</div>
            <div class="card-side type-${getTypeClass(s1.type)}" ${!isDiscard ? `onclick="selectSide(${index}, 1)"` : ''}>
                <span class="side-title">${s1.name}</span>
                <span class="side-stats">T${s1.target} | ${getValStr(s1)}</span>
            </div>
        `;
        
        // Highlight active selection
        if(!isDiscard && players[activePlayerIdx].selection && players[activePlayerIdx].selection.card === card) {
            el.classList.add('selected');
            let sides = el.querySelectorAll('.card-side');
            sides[players[activePlayerIdx].selection.sideIndex].classList.add('active');
        }
    } 
    // Show Stacked/Scored Card
    else {
        let active = card.sides[card.selectedSide];
        let typeCls = getTypeClass(active.type);
        if(active.type === 'Color') typeCls = active.name.toLowerCase();
        
        el.innerHTML = `
            <div class="card-side type-${typeCls} active" style="height:100%">
                <span class="side-title">${active.name}</span>
                <br>
                <span style="font-size:16px;">${getValStr(active)}</span>
            </div>
        `;
        el.style.height = '80px'; 
    }
    return el;
}

function createOpponentHUD(p) {
    let div = document.createElement('div');
    div.className = 'player-hud';
    let status = p.passed ? " <span style='color:orange'>(DONE)</span>" : "";
    
    let html = `
        <div class="hud-header">
            <span>${p.name}${status}</span>
            <span style="color:var(--highlight)">${p.getRoundScore()} VP</span>
        </div>
        <div class="hud-stats">
            Total: ${p.totalScore} | Hand: ${p.hand.length} | Cols: ${p.getUniqueColors()}
        </div>
        <div style="margin-top:5px; display:flex; flex-wrap:wrap;">
    `;
    p.scorePile.forEach(c => {
        let s = c.sides[c.selectedSide];
        let col = getTypeClass(s.type) === 'color' ? s.name.toLowerCase() : '#444';
        if(s.type==='Color') col = s.name.toLowerCase();
        
        html += `
        <div class="mini-card-container">
            <span class="mini-card" style="border-color:${col}; color:${col === '#444' ? 'white' : col};">${s.name[0]}</span>
            <span class="mini-val">${s.value}</span>
        </div>`;
    });
    html += `</div>`;
    div.innerHTML = html;
    return div;
}

function getTypeClass(t) {
    if(t === 'Color') return 'color'; 
    if(t === 'Wild') return 'wild';
    if(t === 'Action') return 'action';
    return 'gray';
}
function getValStr(s) {
    if(s.effect) return s.effect;
    return s.value + " VP";
}

function log(msg, isHeader, type) {
    let div = document.getElementById('game-log');
    let entry = document.createElement('div');
    entry.className = isHeader ? 'log-turn' : 'log-entry';
    if(type) entry.classList.add(type);
    entry.innerText = msg;
    div.prepend(entry);
}
</script>
</body>
</html>