<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER STACK: v2.8 FX FIX</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --card-bg: #161b22;
            --highlight: #58a6ff;
            --danger: #da3633;
            --success: #238636;
            --warning: #d29922;
            --text-main: #c9d1d9;
            --border: #30363d;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        h1 { margin-bottom: 5px; text-shadow: 0 0 10px var(--highlight); }
        .subtitle { font-size: 12px; color: #8b949e; margin-bottom: 20px; }
        
        /* --- SCREENS --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.98);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 500;
        }
        .hidden { display: none !important; }

        .game-container {
            display: flex; flex-direction: column; gap: 20px;
            width: 100%; max-width: 1000px;
        }

        /* --- AREAS --- */
        .opponent-area { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        
        .player-area {
            background: #0d1117; border: 2px solid var(--highlight);
            padding: 20px; border-radius: 8px; min-height: 280px;
            position: relative; /* Essential for FX positioning */
        }
        .turn-indicator {
            position: absolute; top: -15px; left: 20px; 
            background: var(--bg-color); color: var(--highlight); 
            border: 2px solid var(--highlight); padding: 5px 15px;
            font-weight: bold; font-size: 14px; border-radius: 4px;
        }
        
        .info-panel {
            display: flex; justify-content: space-between; background: #21262d;
            padding: 10px; border-radius: 4px; margin-bottom: 10px; margin-top: 10px;
        }

        /* --- CARDS --- */
        .card-zone {
            display: flex; gap: 10px; min-height: 130px; padding: 10px;
            background: rgba(255,255,255,0.05); border-radius: 4px;
            margin-bottom: 10px; align-items: center; overflow-x: auto;
        }
        .card {
            background: var(--card-bg); border: 1px solid var(--border);
            border-radius: 6px; width: 100px; height: 140px;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 5px; font-size: 11px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s; position: relative; flex-shrink: 0;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--highlight); }
        .card.selected { border: 2px solid var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        .card.burning { border: 2px solid var(--danger); opacity: 0.8; } 
        .card.burning::after {
            content: "ðŸ”¥"; position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); font-size: 24px; pointer-events: none;
        }

        .card-side { padding: 4px; border-radius: 3px; text-align: center; background: #21262d; flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .card-side:hover { background: #30363d; }
        .card-side.active { background: #1f6feb; color: white; }
        
        .side-title { font-weight: bold; display: block; margin-bottom: 2px; pointer-events: none; }
        .side-stats { font-size: 10px; color: #8b949e; pointer-events: none; }
        .card-side.active .side-stats { color: #e1e4e8; }

        /* Types */
        .type-red { border-top: 3px solid #ff4444; }
        .type-blue { border-top: 3px solid #4444ff; }
        .type-green { border-top: 3px solid #44ff44; }
        .type-yellow { border-top: 3px solid #ffff44; }
        .type-purple { border-top: 3px solid #aa44ff; }
        .type-wild { border-top: 3px solid white; }
        .type-action { border-top: 3px solid orange; }

        /* --- CONTROLS --- */
        .controls { display: flex; justify-content: center; gap: 20px; margin: 20px 0; align-items: center; }
        .btn-group { display: flex; gap: 10px; }
        button {
            padding: 15px 25px; font-size: 16px; font-weight: bold; color: white;
            border: none; border-radius: 4px; cursor: pointer; font-family: inherit;
        }
        .btn-play { background: var(--success); }
        .btn-play:disabled { background: #30363d; opacity: 0.5; cursor: not-allowed; }
        .btn-pass { background: var(--warning); color: #000; }
        .btn-discard { background: #30363d; color: #fff; border: 1px solid #8b949e; }
        .btn-stats { background: #1f6feb; color: #fff; border: 1px solid #58a6ff; }
        
        .overclock-panel {
            display: flex; flex-direction: column; align-items: center;
            background: #331; padding: 10px; border: 1px solid #774;
            border-radius: 4px; min-width: 120px;
        }

        .dice-box {
            width: 60px; height: 60px; background: white; color: black;
            font-size: 30px; font-weight: bold; display: flex;
            align-items: center; justify-content: center;
            border-radius: 8px; box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        /* --- LOG & MODALS --- */
        #game-log {
            height: 150px; overflow-y: auto; background: #000;
            border: 1px solid var(--border); padding: 10px;
            font-size: 12px; font-family: monospace; color: #0f0;
        }
        .log-turn { color: var(--highlight); border-bottom: 1px solid #333; margin-top: 5px; }
        .log-fail { color: var(--danger); }
        .log-success { color: var(--success); }
        .log-pass { color: var(--warning); }
        .log-win { color: #d29922; font-weight: bold; }

        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 50;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-content {
            background: var(--bg-color); border: 2px solid var(--border);
            padding: 20px; width: 90%; max-width: 900px; max-height: 85vh;
            overflow-y: auto; border-radius: 8px; text-align: center;
        }
        .modal-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding: 10px; }
        
        .target-btn {
            background: #21262d; border: 1px solid var(--highlight); color: white;
            padding: 15px; margin: 5px; cursor: pointer; border-radius: 5px; width: 200px;
        }
        .target-btn:hover { background: var(--highlight); }

        /* --- STATS TABLE --- */
        table.stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #444; padding: 8px; text-align: center; }
        .stats-table th { background: #21262d; color: var(--highlight); }
        .stats-table tr:nth-child(even) { background: #161b22; }

        /* --- HUD --- */
        .player-hud { 
            width: 220px; background: #161b22; padding: 10px; 
            border: 1px solid #30363d; border-radius: 4px; margin-bottom:5px;
            position: relative; /* Essential for FX positioning */
        }
        .hud-header { font-weight: bold; border-bottom: 1px solid #30363d; padding-bottom: 5px; margin-bottom: 5px; display: flex; justify-content: space-between;}
        .hud-stats { display: flex; gap: 10px; font-size: 11px; margin-bottom: 5px; }
        .mini-card-container { display: inline-flex; flex-direction: column; align-items: center; margin: 2px; }
        .mini-card { 
            display: grid; place-items: center; width: 18px; height: 18px; 
            font-size: 10px; border-radius: 3px; border: 2px solid #444; font-weight: bold;
        }
        .mini-val { font-size: 9px; color: #888; margin-top: 2px; }
        
        .selection-group { margin: 10px 0; text-align: center; }
        .sel-btn { background: #21262d; border: 1px solid #30363d; color: white; padding: 10px 20px; margin: 0 5px; }
        .sel-btn.active { background: var(--highlight); border-color: var(--highlight); }

        /* --- TOOLTIP --- */
        #tooltip {
            position: fixed; 
            display: none;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--highlight); 
            color: #fff; 
            padding: 12px;
            font-size: 12px; 
            pointer-events: none; 
            z-index: 99999; 
            max-width: 250px; 
            border-radius: 6px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            white-space: pre-wrap;
            line-height: 1.4;
        }

        /* --- 3D DICE ANIMATION --- */
        #dice-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            perspective: 1000px;
        }
        .cube {
            width: 100px; height: 100px; position: relative;
            transform-style: preserve-3d;
        }
        .face {
            position: absolute; width: 100px; height: 100px;
            background: white; border: 4px solid #333; border-radius: 12px;
            font-size: 50px; font-weight: bold; color: black;
            display: flex; justify-content: center; align-items: center;
            box-shadow: inset 0 0 15px #aaa;
        }
        .front  { transform: translateZ(50px); }
        .back   { transform: rotateY(180deg) translateZ(50px); }
        .right  { transform: rotateY(90deg) translateZ(50px); }
        .left   { transform: rotateY(-90deg) translateZ(50px); }
        .top    { transform: rotateX(90deg) translateZ(50px); }
        .bottom { transform: rotateX(-90deg) translateZ(50px); }

        /* --- VISUAL FX (TARGETED) --- */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        @keyframes zoomFade {
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .fx-text {
            font-weight: 900; text-shadow: 0 0 10px black; letter-spacing: 2px;
            animation: zoomFade 2s ease-out forwards;
            background: rgba(0,0,0,0.7);
        }
        .fx-success { color: #44ff44; border: 3px solid #44ff44; padding: 10px 20px; border-radius: 8px; transform: rotate(-5deg); }
        .fx-fail { color: #ff4444; border: 3px solid #ff4444; padding: 10px 20px; border-radius: 8px; transform: rotate(5deg); }

        .element-shake { animation: shake 0.5s; }

    </style>
</head>
<body>

    <div id="tooltip"></div>

    <div id="dice-overlay" class="hidden">
        <div class="cube" id="dice-cube">
            <div class="face front">1</div>
            <div class="face back">6</div>
            <div class="face right">3</div>
            <div class="face left">4</div>
            <div class="face top">2</div>
            <div class="face bottom">5</div>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 40px; color: var(--highlight);">CYBER STACK</h1>
        <div style="color: var(--warning); font-size: 14px; margin-bottom: 20px;">// v2.8 FX FIX //</div>
        
        <div class="selection-group">
            <div>HUMAN PLAYERS</div>
            <button class="sel-btn active" onclick="setSetup('p', 1)">1</button>
            <button class="sel-btn" onclick="setSetup('p', 2)">2</button>
            <button class="sel-btn" onclick="setSetup('p', 3)">3</button>
            <button class="sel-btn" onclick="setSetup('p', 4)">4</button>
        </div>

        <div class="selection-group">
            <div>CPU OPPONENTS</div>
            <button class="sel-btn" onclick="setSetup('b', 0)">0</button>
            <button class="sel-btn active" onclick="setSetup('b', 1)">1</button>
            <button class="sel-btn" onclick="setSetup('b', 2)">2</button>
            <button class="sel-btn" onclick="setSetup('b', 3)">3</button>
        </div>

        <button class="btn-play" style="margin-top:20px; width: 200px;" onclick="startGame()">INITIALIZE</button>
    </div>

    <div id="discard-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2>DISCARD PILE</h2>
                <button class="btn-pass" onclick="toggleDiscard()">CLOSE</button>
            </div>
            <div id="discard-grid" class="modal-grid"></div>
        </div>
    </div>

    <div id="select-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display:flex; justify-content:center; align-items:center; margin-bottom:15px;">
                <h2 id="select-title">CHOOSE TARGET</h2>
            </div>
            <div id="select-grid" class="modal-grid"></div>
            <div id="select-status" style="margin-top:10px; color:#888;"></div>
        </div>
    </div>

    <div id="stats-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2>GAME LOG & STATS</h2>
                <button class="btn-pass" onclick="toggleStats()">CLOSE</button>
            </div>
            <div style="font-size:11px; color:#888; margin-bottom:10px;">Tracking data for ALL players across ALL rounds.</div>
            <div id="stats-container"></div>
        </div>
    </div>

    <h1>CYBER STACK <span style="font-size:0.5em; color:#666">v2.8</span></h1>
    <div class="subtitle">// ROUND <span id="game-round">1</span> OF 3 // TRIGGER: 5 COLORS //</div>

    <div id="game-root" class="game-container hidden">
        <div id="opponents" class="opponent-area"></div>

        <div class="controls">
            <div id="dice-display" class="dice-box">?</div>
            
            <div class="overclock-panel">
                <div style="font-size: 12px; margin-bottom: 5px; color: #fe9;">OVERCLOCK</div>
                <div style="font-size: 10px; color: #888;">Right-Click Hand</div>
                <div id="bonus-display" style="font-size: 18px; font-weight: bold; color: #fe9;">+0</div>
            </div>

            <div class="btn-group">
                <button id="btn-roll" class="btn-play" onclick="commitTurn()">CONFIRM</button>
                <button id="btn-pass" class="btn-pass" onclick="passTurn()">REBOOT (PASS)</button>
                <button id="btn-disc" class="btn-discard" onclick="toggleDiscard()">DISCARD</button>
                <button id="btn-stats" class="btn-stats" onclick="toggleStats()">STATS</button>
            </div>
            
            <div style="text-align: left; font-size: 12px;">
                <div>TURN: <span id="turn-display">1</span></div>
                <div>PHASE: <span id="phase-display" style="color: var(--highlight)">PLANNING</span></div>
            </div>
        </div>

        <div class="player-area" id="player-main-area">
            <div id="active-player-name" class="turn-indicator">PLAYER 1</div>

            <div class="info-panel">
                <div>
                    <strong>CURRENT SCORE:</strong> 
                    <span id="player-score" style="color: var(--success); margin-left: 10px; font-size: 1.2em;">0 VP</span>
                    <span id="total-score-display" style="color: #888; font-size: 0.8em; margin-left:10px;">(Total: 0)</span>
                </div>
                <div>
                    <span id="hand-count" style="color: #fff;">Hand: 0/5</span> | 
                    <span id="colors-status" style="color: var(--highlight);">Colors: 0/5</span>
                </div>
            </div>

            <div style="font-size: 12px; color: #888; margin-bottom: 5px;">
                SCORE PILE (Collect 5 Distinct Colors to End Round):
            </div>
            <div id="player-score-pile" class="card-zone"></div>

            <div style="font-size: 12px; color: #888; margin-bottom: 5px;">
                HAND (Ammo) | Right-Click to Burn (+1 Roll)
            </div>
            <div id="player-hand" class="card-zone"></div>
        </div>

        <div id="game-log"></div>
    </div>

<script>
/* --- CONFIG --- */
const COLORS = ["Red", "Blue", "Green", "Yellow", "Purple"];
const STARTING_HAND = 3;
const MAX_HAND = 5;
const TRIGGER_COLORS = 5; 
const TOTAL_ROUNDS = 3;

/* --- STATE --- */
let deck = [];
let discardPile = [];
let players = [];
let turnCount = 1;
let currentRound = 1;
let activePlayerIdx = 0; 
let gameOver = false;
let setupP = 1;
let setupB = 1;
let pauseForInteraction = false;

// STATS SYSTEM
let cardStats = {}; // { "Red/Blue": { played:0, s0:0, s1:0, success:0, fail:0, burned:0 } }

/* --- CLASSES --- */
class Card {
    constructor(s1, s2) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.sides = [s1, s2];
        this.selectedSide = 0; 
        this.isBurning = false; 
    }
}

class Player {
    constructor(name, isBot) {
        this.name = name;
        this.isBot = isBot;
        this.hand = [];
        this.scorePile = [];
        this.cache = [];
        this.passed = false;
        this.selection = null; 
        this.bonus = 0;
        this.totalScore = 0; 
    }

    getRoundScore() {
        let s = 0;
        this.scorePile.forEach(c => s += c.sides[c.selectedSide].value);
        this.cache.forEach(c => s += c.sides[c.selectedSide].value);
        return s;
    }

    getUniqueColors() {
        let colorSet = new Set();
        let wildCount = 0;
        this.scorePile.forEach(c => {
            let s = c.sides[c.selectedSide];
            if(s.type === 'Color') colorSet.add(s.name);
            if(s.type === 'Wild') wildCount++;
        });
        return Math.min(TRIGGER_COLORS, colorSet.size + wildCount); 
    }

    resetForRound() {
        this.hand = [];
        this.scorePile = [];
        this.cache = [];
        this.passed = false;
        this.selection = null;
        this.bonus = 0;
    }
}

/* --- STATS LOGIC --- */
function getCardKey(card) {
    return card.sides[0].name + " / " + card.sides[1].name;
}

function updateStat(card, action, sIdx) {
    let key = getCardKey(card);
    if (!cardStats[key]) {
        cardStats[key] = { played:0, s0:0, s1:0, success:0, fail:0, burned:0 };
    }
    
    if (action === 'burn') {
        cardStats[key].burned++;
    } else if (action === 'play') {
        cardStats[key].played++;
        if(sIdx === 0) cardStats[key].s0++;
        else cardStats[key].s1++;
    } else if (action === 'success') {
        cardStats[key].success++;
    } else if (action === 'fail') {
        cardStats[key].fail++;
    }
}

function renderStats() {
    let container = document.getElementById('stats-container');
    let html = `
    <table class="stats-table">
        <thead>
            <tr>
                <th>CARD</th>
                <th>PLAYED</th>
                <th>S1 USED</th>
                <th>S2 USED</th>
                <th>SUCCESS</th>
                <th>FAILED</th>
                <th>BURNED</th>
                <th>WIN RATE</th>
            </tr>
        </thead>
        <tbody>
    `;
    
    // Sort by name
    let sortedKeys = Object.keys(cardStats).sort();
    
    sortedKeys.forEach(key => {
        let d = cardStats[key];
        let totalRes = d.success + d.fail;
        let wr = totalRes > 0 ? Math.round((d.success / totalRes) * 100) + "%" : "-";
        
        let names = key.split(' / ');
        let s1Name = names[0];
        let s2Name = names[1];

        let s1Pct = d.played > 0 ? Math.round((d.s0 / d.played)*100) : 0;
        let s2Pct = d.played > 0 ? Math.round((d.s1 / d.played)*100) : 0;

        html += `
        <tr>
            <td style="font-weight:bold; color:#ddd;">${key}</td>
            <td>${d.played}</td>
            <td><span style="color:${getColorHex(s1Name)}">${s1Name}</span> (${s1Pct}%)</td>
            <td><span style="color:${getColorHex(s2Name)}">${s2Name}</span> (${s2Pct}%)</td>
            <td style="color:#238636">${d.success}</td>
            <td style="color:#da3633">${d.fail}</td>
            <td style="color:#d29922">${d.burned}</td>
            <td>${wr}</td>
        </tr>`;
    });
    
    html += `</tbody></table>`;
    container.innerHTML = html;
}

function getColorHex(name) {
    if(name === 'Red') return '#ff4444';
    if(name === 'Blue') return '#4444ff';
    if(name === 'Green') return '#44ff44';
    if(name === 'Yellow') return '#ffff44';
    if(name === 'Purple') return '#aa44ff';
    return '#888';
}

/* --- SETUP & INIT --- */
function setSetup(type, val) {
    if(type === 'p') setupP = val;
    if(type === 'b') setupB = val;
    
    let group = type === 'p' ? document.querySelectorAll('.selection-group')[0] : document.querySelectorAll('.selection-group')[1];
    Array.from(group.querySelectorAll('.sel-btn')).forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-root').classList.remove('hidden');

    players = [];
    for(let i=1; i<=setupP; i++) players.push(new Player(`PLAYER ${i}`, false));
    for(let i=1; i<=setupB; i++) players.push(new Player(`CPU ${i}`, true));

    currentRound = 1;
    cardStats = {}; 
    startNewRound();
}

function startNewRound() {
    turnCount = 1;
    deck = generateDeck();
    discardPile = [];
    
    players.forEach(p => {
        p.resetForRound();
        drawCards(p, STARTING_HAND);
    });

    log(`=== STARTING ROUND ${currentRound} OF ${TOTAL_ROUNDS} ===`, true);
    document.getElementById('game-round').innerText = currentRound;
    
    activePlayerIdx = 0;
    updateUI();
}

function generateDeck() {
    let d = [];
    // Colors
    for(let i=0; i<COLORS.length; i++) {
        for(let j=i+1; j<COLORS.length; j++) {
            let c1 = COLORS[i], c2 = COLORS[j];
            d.push(new Card({name:c1, type:'Color', target:5, value:4}, {name:c2, type:'Color', target:3, value:1}));
            d.push(new Card({name:c1, type:'Color', target:4, value:3}, {name:c2, type:'Color', target:4, value:3}));
            d.push(new Card({name:c1, type:'Color', target:3, value:2}, {name:c2, type:'Color', target:5, value:4}));
        }
    }
    COLORS.forEach(c => {
        d.push(new Card({name:'Wild', type:'Wild', target:6, value:5}, {name:c, type:'Color', target:2, value:1}));
    });
    
    // --- RENAMED CARDS ---
    for(let i=0; i<5; i++) {
        d.push(new Card({name:'Draw +2', type:'Action', effect:'Draw +2', target:4, value:0}, {name:'Data Cache', type:'Point', target:3, value:2}));
    }
    for(let i=0; i<4; i++) {
        d.push(new Card({name:'Steal', type:'Action', effect:'Steal', target:4, value:0}, {name:'Scavenge', type:'Action', effect:'Scavenge', target:3, value:0}));
    }
    return shuffle(d);
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function drawCards(p, count) {
    for(let i=0; i<count; i++) {
        if(deck.length === 0 && discardPile.length > 0) {
            deck = shuffle([...discardPile]);
            discardPile = [];
        }
        if(deck.length > 0) {
            if(p.hand.length < MAX_HAND) {
                p.hand.push(deck.pop());
            } else {
                discardPile.push(deck.pop());
            }
        }
    }
}

/* --- PLAYER ACTIONS --- */
function passTurn() {
    let p = players[activePlayerIdx];
    p.passed = true;
    p.selection = null;
    p.hand.forEach(c => c.isBurning = false);
    p.bonus = 0;
    log(`${p.name} REBOOTS (Pass).`);
    advanceQueue();
}

function commitTurn() {
    let p = players[activePlayerIdx];
    if (!p.selection) {
        alert("Select a card to play first!");
        return;
    }
    
    // Lock in Burning
    p.bonus = 0;
    let finalHand = [];
    p.hand.forEach(c => {
        if (c.isBurning) {
            discardPile.push(c);
            updateStat(c, 'burn'); 
            p.bonus++;
        } else {
            finalHand.push(c);
        }
    });
    p.hand = finalHand;

    // Safety
    if (!p.hand.includes(p.selection.card)) {
        p.passed = true;
        p.selection = null;
    }

    advanceQueue();
}

function advanceQueue() {
    activePlayerIdx++;
    
    // Find next human
    if(activePlayerIdx < players.length && !players[activePlayerIdx].isBot) {
        updateUI();
    } else {
        processBots();
        triggerDiceRoll();
    }
}

/* --- DICE ANIMATION LOGIC --- */
function triggerDiceRoll() {
    let overlay = document.getElementById('dice-overlay');
    let cube = document.getElementById('dice-cube');
    
    cube.style.transition = 'none';
    cube.style.transform = 'rotateX(0deg) rotateY(0deg)';
    void cube.offsetWidth;
    overlay.classList.remove('hidden');
    
    let roll = Math.floor(Math.random() * 6) + 1;
    let xBase = 720 + (Math.floor(Math.random() * 2) * 360); 
    let yBase = 720 + (Math.floor(Math.random() * 2) * 360);
    let target = getRotationFor(roll);
    
    setTimeout(() => {
        cube.style.transition = 'transform 1.2s cubic-bezier(0.1, 0.7, 0.1, 1)'; 
        cube.style.transform = `rotateX(${xBase + target.x}deg) rotateY(${yBase + target.y}deg)`;
    }, 50); 

    setTimeout(() => {
        overlay.classList.add('hidden');
        executeRound(roll); 
    }, 1500);
}

function getRotationFor(num) {
    switch(num) {
        case 1: return {x: 0, y: 0};
        case 6: return {x: 0, y: 180}; 
        case 2: return {x: -90, y: 0}; 
        case 5: return {x: 90, y: 0};  
        case 3: return {x: 0, y: -90}; 
        case 4: return {x: 0, y: 90};  
    }
    return {x:0, y:0};
}

/* --- EXECUTION PHASE --- */
function processBots() {
    players.filter(p => p.isBot).forEach(bot => {
        bot.bonus = 0;
        bot.passed = false;
        bot.selection = null;

        if (bot.hand.length === 0) { bot.passed = true; return; }

        let best = null;
        let bestScore = -99;

        bot.hand.forEach((c, idx) => {
            c.sides.forEach((s, sIdx) => {
                let score = s.value + (6 - s.target);
                if(s.type === 'Color' && !hasColor(bot, s.name)) score += 5;
                if(score > bestScore) { bestScore = score; best = {card:c, side:sIdx}; }
            });
        });

        if(best) {
            bot.selection = {card: best.card, sideIndex: best.side};
            if(best.card.sides[best.side].target >= 5 && bot.hand.length > 3) {
                let burn = bot.hand.find(c => c !== best.card);
                if(burn) {
                    bot.hand = bot.hand.filter(x => x!==burn);
                    discardPile.push(burn);
                    updateStat(burn, 'burn'); 
                    bot.bonus = 1;
                }
            }
        } else {
            bot.passed = true;
        }
    });
}

function hasColor(p, name) {
    return p.scorePile.some(c => c.sides[c.selectedSide].name === name);
}

function executeRound(baseRoll) {
    document.getElementById('dice-display').innerText = baseRoll;
    log(`--- TURN ${turnCount} | ROLL: [ ${baseRoll} ] ---`, true);
    
    pauseForInteraction = false;

    // Resolve BOTS first (instant)
    players.filter(p => p.isBot).forEach(p => resolvePlayer(p, baseRoll));
    
    // Resolve HUMANS
    players.filter(p => !p.isBot).forEach(p => resolvePlayer(p, baseRoll));

    // If a human entered an interactive state (Steal/Scavenge), we stop here.
    if (!pauseForInteraction) {
        // --- DELAY HERE TO ALLOW FX TO BE SEEN ---
        setTimeout(finishTurnSequence, 2500);
    }
}

function finishTurnSequence() {
    let roundEnded = players.some(p => p.getUniqueColors() >= TRIGGER_COLORS);

    if(roundEnded) {
        endRound();
    } else {
        players.forEach(p => {
            drawCards(p, 1);
            p.selection = null;
            p.passed = false;
            p.bonus = 0;
            p.hand.forEach(c => c.isBurning = false);
        });
        activePlayerIdx = 0;
        turnCount++;
        updateUI();
    }
}

/* --- TARGETED VISUAL FX LOGIC --- */
function triggerVisualFX(type, p) {
    // 1. Identify Target DOM Element
    // Try to find specific HUD first
    let hudId = `hud-p${players.indexOf(p)}`;
    let targetEl = document.getElementById(hudId);

    // If no HUD found, assume they are the Main Player currently on screen
    if (!targetEl) {
        targetEl = document.getElementById('player-main-area');
    }
    
    if (!targetEl) return;

    // 2. Create FX Wrapper to Center Text
    let wrapper = document.createElement('div');
    wrapper.style.position = "absolute";
    wrapper.style.top = "50%";
    wrapper.style.left = "50%";
    wrapper.style.transform = "translate(-50%, -50%)"; // Center in parent
    wrapper.style.zIndex = "100";
    wrapper.style.pointerEvents = "none";
    wrapper.style.width = "100%";
    wrapper.style.textAlign = "center";

    // 3. Create Text Element
    let text = document.createElement('div');
    text.className = `fx-text ${type === 'success' ? 'fx-success' : 'fx-fail'}`;
    text.innerText = type === 'success' ? "SUCCESS" : "FAILURE";
    
    // Scale down for bots/opponents (if targeted element is small HUD)
    if (targetEl.classList.contains('player-hud')) {
        text.style.fontSize = "20px";
        text.style.padding = "5px 10px";
        text.style.borderWidth = "2px";
    } else {
        text.style.fontSize = "60px"; // Big for main player
    }

    wrapper.appendChild(text);
    targetEl.appendChild(wrapper);

    // 4. Shake Effect (Only on Failure)
    if (type === 'fail') {
        targetEl.classList.add('element-shake');
        setTimeout(() => {
            targetEl.classList.remove('element-shake');
        }, 500);
    }

    // 5. Cleanup
    setTimeout(() => {
        wrapper.remove();
    }, 2000);
}


function resolvePlayer(p, baseRoll) {
    if(p.passed || !p.selection) return;

    let card = p.selection.card;
    let sIdx = p.selection.sideIndex;
    let side = card.sides[sIdx];
    let total = baseRoll + p.bonus;

    updateStat(card, 'play', sIdx);

    let hIdx = p.hand.indexOf(card);
    if(hIdx > -1) p.hand.splice(hIdx, 1);

    if(total >= side.target) {
        log(`${p.name} Success: ${side.name} (${side.value} VP)`, false, 'success');
        updateStat(card, 'success'); 
        
        // TRIGGER TARGETED SUCCESS
        triggerVisualFX('success', p);

        card.selectedSide = sIdx;
        
        if (side.effect === 'Draw +2') {
            drawCards(p, 2);
            log(`> Draw +2 executed!`);
            discardPile.push(card);
        } else if (side.effect === 'Steal') {
            discardPile.push(card); // Card is used up
            if (!p.isBot) {
                // HUMAN INTERACTION
                pauseForInteraction = true;
                openStealUI(p);
            } else {
                handleBotSteal(p);
            }
        } else if (side.effect === 'Scavenge') {
            discardPile.push(card); 
            if (!p.isBot) {
                pauseForInteraction = true;
                openScavengeUI(p);
            } else {
                if(discardPile.length > 0) p.hand.push(discardPile.pop());
            }
        } else if (side.type === 'Point') {
            p.cache.push(card);
        } else {
            p.scorePile.push(card);
        }
    } else {
        log(`${p.name} Fails ${side.name} (Rolled ${total})`, false, 'fail');
        updateStat(card, 'fail'); 
        
        // TRIGGER TARGETED FAIL
        triggerVisualFX('fail', p);
        
        discardPile.push(card);
    }
}

/* --- INTERACTIVE MECHANICS --- */

function openStealUI(player) {
    let modal = document.getElementById('select-modal');
    let grid = document.getElementById('select-grid');
    let title = document.getElementById('select-title');
    let status = document.getElementById('select-status');
    
    // Step 1: Select Opponent
    title.innerText = "CHOOSE VICTIM";
    status.innerText = "Select a player to hack.";
    grid.innerHTML = "";
    
    let victims = players.filter(v => v !== player && v.scorePile.length > 0);
    
    if (victims.length === 0) {
        log("> No valid targets to steal from.");
        modal.classList.add('hidden');
        pauseForInteraction = false;
        finishTurnSequence();
        return;
    }
    
    modal.classList.remove('hidden');
    
    victims.forEach(v => {
        let btn = document.createElement('div');
        btn.className = 'target-btn';
        btn.innerHTML = `<b>${v.name}</b><br>${v.scorePile.length} Cards`;
        btn.onclick = () => showVictimCards(player, v);
        grid.appendChild(btn);
    });
}

function showVictimCards(player, victim) {
    let grid = document.getElementById('select-grid');
    let title = document.getElementById('select-title');
    let status = document.getElementById('select-status');
    
    title.innerText = `STEAL FROM ${victim.name}`;
    status.innerText = "Click a card to steal it.";
    grid.innerHTML = "";
    
    victim.scorePile.forEach((c, i) => {
        // Render simple version
        let s = c.sides[c.selectedSide];
        let el = document.createElement('div');
        el.className = 'card';
        el.style.height = '100px'; 
        el.innerHTML = `
            <div class="card-side active type-${getTypeClass(s.type)}" style="height:100%">
                <span class="side-title">${s.name}</span>
                <br><span>${s.value} VP</span>
            </div>
        `;
        el.onclick = () => {
            // EXECUTE STEAL
            victim.scorePile.splice(i, 1);
            player.scorePile.push(c);
            log(`> You stole ${s.name} from ${victim.name}!`, false, 'success');
            
            document.getElementById('select-modal').classList.add('hidden');
            finishTurnSequence();
        };
        grid.appendChild(el);
    });
}

function openScavengeUI(player) {
    let modal = document.getElementById('select-modal');
    let grid = document.getElementById('select-grid');
    let title = document.getElementById('select-title');
    let status = document.getElementById('select-status');
    
    title.innerText = "SCAVENGE";
    status.innerText = "Choose a card to return to your hand.";
    grid.innerHTML = "";
    
    // Filter out the card just played if it's the only one (optional, but cleaner logic)
    // Here we just show the whole pile.
    if (discardPile.length === 0) {
        log("> Discard pile empty. Scavenge failed.");
        finishTurnSequence();
        return;
    }

    modal.classList.remove('hidden');
    
    discardPile.forEach((c, i) => {
        // Use standard card render but with onclick
        let el = createCardElement(c, false, -1, true); // Visual only
        el.style.cursor = 'pointer';
        el.style.pointerEvents = 'auto'; // Re-enable for this modal
        
        // Remove existing onclicks from createCardElement and replace
        let sides = el.querySelectorAll('.card-side');
        sides.forEach(s => s.onclick = null);
        
        el.onclick = () => {
            // EXECUTE SCAVENGE
            discardPile.splice(i, 1);
            player.hand.push(c);
            log(`> You scavenged a card from the trash.`, false, 'success');
            
            modal.classList.add('hidden');
            finishTurnSequence();
        };
        
        grid.appendChild(el);
    });
}


function handleBotSteal(attacker) {
    let targets = players.filter(pl => pl !== attacker && pl.scorePile.length > 0);
    if(targets.length) {
        let victim = targets[Math.floor(Math.random()*targets.length)];
        let stolen = victim.scorePile.pop();
        attacker.scorePile.push(stolen);
        log(`> Stole ${stolen.sides[stolen.selectedSide].name} from ${victim.name}!`);
    } else {
        log(`> No targets for ${attacker.name} to steal from.`);
    }
}

function endRound() {
    let msg = `ROUND ${currentRound} COMPLETE! SCORES:\n`;
    players.forEach(p => {
        let s = p.getRoundScore();
        p.totalScore += s;
        msg += `${p.name}: ${s} (Total: ${p.totalScore})\n`;
    });
    alert(msg);

    if (currentRound < TOTAL_ROUNDS) {
        currentRound++;
        startNewRound();
    } else {
        endGame();
    }
}

function endGame() {
    let winner = players.sort((a,b) => b.totalScore - a.totalScore)[0];
    alert(`TOURNAMENT OVER!\n\nWINNER: ${winner.name}\nFINAL SCORE: ${winner.totalScore}`);
    location.reload();
}

/* --- UI --- */
function selectSide(cIdx, sIdx) {
    let p = players[activePlayerIdx];
    let card = p.hand[cIdx];
    if(card.isBurning) return; 
    p.selection = {card: card, sideIndex: sIdx};
    updateUI();
}

function toggleBurn(cIdx) {
    let p = players[activePlayerIdx];
    let card = p.hand[cIdx];
    if(p.selection && p.selection.card === card) return; 
    card.isBurning = !card.isBurning;
    p.bonus = p.hand.filter(c => c.isBurning).length;
    updateUI();
}

function toggleDiscard() {
    let modal = document.getElementById('discard-modal');
    if(modal.classList.contains('hidden')) {
        modal.classList.remove('hidden');
        let grid = document.getElementById('discard-grid');
        grid.innerHTML = '';
        discardPile.forEach(c => {
            let d = createCardElement(c, true, -1, true);
            d.style.cursor = 'default';
            grid.appendChild(d);
        });
    } else {
        modal.classList.add('hidden');
    }
}

function toggleStats() {
    let modal = document.getElementById('stats-modal');
    if(modal.classList.contains('hidden')) {
        modal.classList.remove('hidden');
        renderStats();
    } else {
        modal.classList.add('hidden');
    }
}

function updateUI() {
    let p = players[activePlayerIdx];
    
    document.getElementById('active-player-name').innerText = `${p.name}'S TURN`;
    document.getElementById('turn-display').innerText = turnCount;
    document.getElementById('btn-roll').innerText = (activePlayerIdx < players.length - players.filter(x=>x.isBot).length - 1) ? "NEXT PLAYER" : "EXECUTE ROUND";

    document.getElementById('player-score').innerText = `${p.getRoundScore()} VP`;
    document.getElementById('total-score-display').innerText = `(Total: ${p.totalScore})`;
    document.getElementById('colors-status').innerText = `Colors: ${p.getUniqueColors()}/${TRIGGER_COLORS}`;
    document.getElementById('bonus-display').innerText = `+${p.bonus}`;
    document.getElementById('hand-count').innerText = `Hand: ${p.hand.length}/${MAX_HAND}`;
    document.getElementById('btn-disc').innerText = `DISCARD (${discardPile.length})`;

    let handDiv = document.getElementById('player-hand');
    handDiv.innerHTML = '';
    p.hand.forEach((card, idx) => {
        let el = createCardElement(card, true, idx);
        el.oncontextmenu = (e) => { e.preventDefault(); toggleBurn(idx); };
        handDiv.appendChild(el);
    });

    let pileDiv = document.getElementById('player-score-pile');
    pileDiv.innerHTML = '';
    p.scorePile.forEach(card => pileDiv.appendChild(createCardElement(card, false)));

    let oppDiv = document.getElementById('opponents');
    oppDiv.innerHTML = '';
    players.forEach((opp, i) => {
        if(i !== activePlayerIdx) {
            oppDiv.appendChild(createOpponentHUD(opp));
        }
    });

    document.getElementById('btn-roll').disabled = !p.selection;
}

// --- GLOBAL TOOLTIP DELEGATION ---
document.addEventListener('mouseover', (e) => {
    let target = e.target.closest('[data-tooltip]');
    if (target) {
        showTooltip(e, target.getAttribute('data-tooltip'));
    }
});
document.addEventListener('mouseout', (e) => {
    let target = e.target.closest('[data-tooltip]');
    if (target) {
        hideTooltip();
    }
});
document.addEventListener('mousemove', (e) => {
    if (document.getElementById('tooltip').style.display === 'block') {
        moveTooltip(e);
    }
});

function showTooltip(e, text) {
    let tt = document.getElementById('tooltip');
    tt.style.display = 'block';
    tt.innerText = text;
    moveTooltip(e);
}
function moveTooltip(e) {
    let tt = document.getElementById('tooltip');
    tt.style.left = (e.clientX + 15) + 'px';
    tt.style.top = (e.clientY + 15) + 'px';
}
function hideTooltip() {
    document.getElementById('tooltip').style.display = 'none';
}

function createCardElement(card, interactable, index, isDiscard = false) {
    let el = document.createElement('div');
    el.className = 'card';
    if(card.isBurning) el.classList.add('burning');
    
    // --- BUILD DESCRIPTION ---
    let desc = "";
    if (interactable || isDiscard) {
        let s1 = card.sides[0], s2 = card.sides[1];
        desc = `[${s1.name}]\nTarget: ${s1.target}\nEffect: ${getValStr(s1)}\n\n[${s2.name}]\nTarget: ${s2.target}\nEffect: ${getValStr(s2)}`;
    } else {
        let s = card.sides[card.selectedSide];
        desc = `[${s.name}]\nTarget: ${s.target}\nEffect: ${getValStr(s)}`;
    }
    
    // Add data attribute for the global listener
    el.setAttribute('data-tooltip', desc);
    
    let s0 = card.sides[0];
    let s1 = card.sides[1];
    
    if (interactable || isDiscard) {
        el.innerHTML = `
            <div class="card-side type-${getTypeClass(s0.type)}" ${!isDiscard ? `onclick="selectSide(${index}, 0)"` : ''}>
                <span class="side-title">${s0.name}</span>
                <span class="side-stats">T${s0.target} | ${getValStr(s0)}</span>
            </div>
            <div style="text-align:center; color:#444; font-size:9px;">- OR -</div>
            <div class="card-side type-${getTypeClass(s1.type)}" ${!isDiscard ? `onclick="selectSide(${index}, 1)"` : ''}>
                <span class="side-title">${s1.name}</span>
                <span class="side-stats">T${s1.target} | ${getValStr(s1)}</span>
            </div>
        `;
        
        if(!isDiscard && players[activePlayerIdx].selection && players[activePlayerIdx].selection.card === card) {
            el.classList.add('selected');
            let sides = el.querySelectorAll('.card-side');
            sides[players[activePlayerIdx].selection.sideIndex].classList.add('active');
        }
    } 
    else {
        let active = card.sides[card.selectedSide];
        let typeCls = getTypeClass(active.type);
        if(active.type === 'Color') typeCls = active.name.toLowerCase();
        
        el.innerHTML = `
            <div class="card-side type-${typeCls} active" style="height:100%">
                <span class="side-title">${active.name}</span>
                <br>
                <span style="font-size:16px;">${getValStr(active)}</span>
            </div>
        `;
        el.style.height = '80px'; 
    }
    return el;
}

function createOpponentHUD(p) {
    let div = document.createElement('div');
    div.className = 'player-hud';
    // IMPORTANT: ID needed for targeted FX
    div.id = `hud-p${players.indexOf(p)}`;
    
    let status = p.passed ? " <span style='color:orange'>(DONE)</span>" : "";
    
    let html = `
        <div class="hud-header">
            <span>${p.name}${status}</span>
            <span style="color:var(--highlight)">${p.getRoundScore()} VP</span>
        </div>
        <div class="hud-stats">
            Total: ${p.totalScore} | Hand: ${p.hand.length} | Cols: ${p.getUniqueColors()}
        </div>
        <div style="margin-top:5px; display:flex; flex-wrap:wrap;">
    `;
    p.scorePile.forEach(c => {
        let s = c.sides[c.selectedSide];
        let col = getTypeClass(s.type) === 'color' ? s.name.toLowerCase() : '#444';
        if(s.type==='Color') col = s.name.toLowerCase();
        
        html += `
        <div class="mini-card-container">
            <span class="mini-card" style="border-color:${col}; color:${col === '#444' ? 'white' : col};">${s.name[0]}</span>
            <span class="mini-val">${s.value}</span>
        </div>`;
    });
    html += `</div>`;
    div.innerHTML = html;
    
    div.setAttribute('data-tooltip', `${p.name}\nRound Score: ${p.getRoundScore()}\nTotal Tournament Score: ${p.totalScore}`);
    return div;
}

function getTypeClass(t) {
    if(t === 'Color') return 'color'; 
    if(t === 'Wild') return 'wild';
    if(t === 'Action') return 'action';
    return 'gray';
}
function getValStr(s) {
    if(s.effect) return s.effect;
    return s.value + " VP";
}

function log(msg, isHeader, type) {
    let div = document.getElementById('game-log');
    let entry = document.createElement('div');
    entry.className = isHeader ? 'log-turn' : 'log-entry';
    if(type) entry.classList.add(type);
    entry.innerText = msg;
    div.prepend(entry);
}
</script>
</body>
</html>