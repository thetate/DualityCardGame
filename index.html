<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER STACK: v4.8 BALANCED</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --card-bg: #161b22;
            --highlight: #58a6ff;
            --danger: #da3633;
            --success: #238636;
            --warning: #d29922;
            --text-main: #c9d1d9;
            --border: #30363d;
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
        }
        h1 { margin-bottom: 5px; text-shadow: 0 0 10px var(--highlight); }
        .subtitle { font-size: 12px; color: #8b949e; margin-bottom: 20px; }
        .hidden { display: none !important; }

        /* SCREENS & MODALS */
        #start-screen, #coin-modal, #discard-modal, #select-modal, #stats-modal, #dice-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 500;
        }
        #start-screen { background: rgba(13, 17, 23, 0.98); }
        #dice-overlay { background: rgba(0,0,0,0.85); z-index: 2000; perspective: 1000px; pointer-events: none; }
        .modal-overlay { background: rgba(0,0,0,0.9); z-index: 2100 !important; }
        
        .modal-content {
            background: var(--bg-color); border: 2px solid var(--border);
            padding: 20px; width: 90%; max-width: 900px; max-height: 85vh;
            overflow-y: auto; border-radius: 8px; text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        .modal-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding: 10px; }

        /* LAYOUT */
        .game-container { display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 1000px; }
        .opponent-area { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .player-area { background: #0d1117; border: 2px solid var(--highlight); padding: 20px; border-radius: 8px; min-height: 280px; position: relative; }
        .info-panel { display: flex; justify-content: space-between; background: #21262d; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .pot-display { display: flex; gap: 15px; background: #161b22; border: 1px solid var(--warning); padding: 5px 15px; border-radius: 4px; align-items: center; }

        /* CARDS */
        .card-zone { display: flex; gap: 10px; min-height: 130px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px; overflow-x: auto; }
        .card {
            background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; width: 100px; height: 140px;
            display: flex; flex-direction: column; justify-content: space-between; padding: 5px; font-size: 11px; cursor: pointer;
            transition: transform 0.2s; position: relative; flex-shrink: 0;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--highlight); }
        .card.selected { border: 2px solid var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        .card.burning { border: 2px solid var(--danger); opacity: 0.8; }
        .card.burning::after { content: "üî•"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; }
        
        .card-side { padding: 4px; border-radius: 3px; text-align: center; background: #21262d; flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .card-side:hover { background: #30363d; }
        .card-side.active { background: #1f6feb; color: white; }
        .card-side.inactive { opacity: 0.3; }
        
        .type-red { border-top: 3px solid #ff4444; }
        .type-blue { border-top: 3px solid #4444ff; }
        .type-green { border-top: 3px solid #44ff44; }
        .type-yellow { border-top: 3px solid #ffff44; }
        .type-purple { border-top: 3px solid #aa44ff; }
        .type-wild { border-top: 3px solid white; }
        .type-action { border-top: 3px solid orange; }
        .type-gray { border-top: 3px solid #555; }

        /* CONTROLS */
        .controls { display: flex; justify-content: center; gap: 20px; margin: 20px 0; align-items: center; }
        .btn-group { display: flex; gap: 10px; }
        button { padding: 15px 25px; font-size: 16px; font-weight: bold; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; }
        .btn-play { background: var(--success); }
        .btn-play:disabled { background: #30363d; opacity: 0.5; cursor: not-allowed; }
        .btn-pass { background: var(--warning); color: #000; }
        .btn-discard { background: #30363d; color: #fff; border: 1px solid #8b949e; }
        .btn-stats { background: #1f6feb; color: #fff; border: 1px solid #58a6ff; }
        
        .overclock-panel { display: flex; flex-direction: column; align-items: center; background: #331; padding: 10px; border: 1px solid #774; border-radius: 4px; min-width: 120px; }
        .dice-box { width: 60px; height: 60px; background: white; color: black; font-size: 30px; font-weight: bold; display: flex; align-items: center; justify-content: center; border-radius: 8px; }
        
        .target-btn { background: #21262d; border: 1px solid var(--highlight); color: white; padding: 15px; margin: 5px; cursor: pointer; border-radius: 5px; width: 200px; display:inline-block; vertical-align:top; }
        .target-btn:hover { background: var(--highlight); }
        .back-btn { background: #da3633; color: white; padding: 10px; margin: 10px auto; cursor: pointer; border-radius: 5px; font-weight: bold; display:block; width: 120px; }
        .back-btn:hover { background: #ff4444; }

        /* INPUTS */
        .token-input {
            width: 45px;
            background: #21262d;
            border: 1px solid #30363d;
            color: var(--highlight);
            padding: 8px;
            font-family: inherit;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            border-radius: 4px;
        }
        .token-input:focus { outline: none; border-color: var(--highlight); box-shadow: 0 0 5px var(--highlight); }

        /* HUD & LOG */
        #game-log { height: 150px; overflow-y: auto; background: #000; border: 1px solid var(--border); padding: 10px; font-size: 12px; font-family: monospace; color: #0f0; }
        .log-turn { color: var(--highlight); border-bottom: 1px solid #333; margin-top: 5px; }
        .player-hud { width: 220px; background: #161b22; padding: 10px; border: 1px solid #30363d; border-radius: 4px; margin-bottom:5px; position: relative; }
        .hud-header { font-weight: bold; border-bottom: 1px solid #30363d; padding-bottom: 5px; display: flex; justify-content: space-between; }
        .hud-stats { display: flex; gap: 10px; font-size: 11px; margin-bottom: 5px; }
        .mini-card-container { display: inline-flex; flex-direction: column; align-items: center; margin: 2px; }
        .mini-card { display: grid; place-items: center; width: 18px; height: 18px; font-size: 10px; border-radius: 3px; border: 2px solid #444; font-weight: bold; }
        .mini-val { font-size: 9px; color: #888; margin-top: 2px; }
        
        /* 3D ELEMENTS */
        .coin-container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin: 30px 0; perspective: 800px; }
        .coin { width: 80px; height: 80px; position: relative; transform-style: preserve-3d; transition: transform 1s ease-out; }
        .coin-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 24px; border: 4px solid #d29922; }
        .face-heads { background: #ffd700; color: #333; }
        .face-tails { background: #b8860b; color: #fff; transform: rotateY(180deg); }

        .cube { width: 100px; height: 100px; position: relative; transform-style: preserve-3d; }
        .face { position: absolute; width: 100px; height: 100px; background: white; border: 4px solid #333; border-radius: 12px; font-size: 50px; font-weight: bold; color: black; display: flex; justify-content: center; align-items: center; }
        .front { transform: translateZ(50px); } .back { transform: rotateY(180deg) translateZ(50px); }
        .right { transform: rotateY(90deg) translateZ(50px); } .left { transform: rotateY(-90deg) translateZ(50px); }
        .top { transform: rotateX(90deg) translateZ(50px); } .bottom { transform: rotateX(-90deg) translateZ(50px); }

        /* FX */
        @keyframes shake { 0%,100% { transform: translate(0,0); } 25% { transform: translate(-2px,2px); } 75% { transform: translate(2px,-2px); } }
        @keyframes zoomFade { 0% { transform: scale(0.5); opacity: 0; } 20% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }
        .fx-text { font-weight: 900; text-shadow: 0 0 10px black; animation: zoomFade 2s ease-out forwards; background: rgba(0,0,0,0.7); pointer-events: none; }
        .fx-success { color: #44ff44; border: 3px solid #44ff44; padding: 10px 20px; border-radius: 8px; transform: rotate(-5deg); }
        .fx-fail { color: #ff4444; border: 3px solid #ff4444; padding: 10px 20px; border-radius: 8px; transform: rotate(5deg); }
        .element-shake { animation: shake 0.5s; }
        
        .floating-card {
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            margin: 0;
        }

        #tooltip { position: fixed; display: none; background: rgba(0,0,0,0.95); border: 1px solid #58a6ff; color: #fff; padding: 12px; z-index: 99999; border-radius: 6px; pointer-events: none; white-space: pre-wrap; line-height: 1.4; box-shadow: 0 4px 15px rgba(0,0,0,0.8); }
        
        .selection-group { margin: 10px 0; text-align: center; }
        .sel-btn { background: #21262d; border: 1px solid #30363d; color: white; padding: 10px 20px; margin: 0 5px; }
        .sel-btn.active { background: var(--highlight); border-color: var(--highlight); }
    </style>
</head>
<body>

    <div id="tooltip"></div>

    <div id="dice-overlay" class="hidden">
        <div class="cube" id="dice-cube">
            <div class="face front">1</div><div class="face back">6</div><div class="face right">3</div><div class="face left">4</div><div class="face top">2</div><div class="face bottom">5</div>
        </div>
    </div>

    <div id="coin-modal" class="modal-overlay hidden">
        <div class="modal-content" style="max-width:600px">
            <h2>TOKEN DROP</h2>
            <div id="token-subtitle" style="color:#888; margin-bottom:20px;">Flipping Tokens...<br>‚≠ê = Most Points | üé® = First to 5 Colors</div>
            <div id="coin-area" class="coin-container"></div>
            <div id="coin-result" style="font-size:20px; font-weight:bold; margin:20px 0; color:var(--highlight); min-height:30px;"></div>
            <button id="btn-drop" class="btn-play" onclick="executeCoinDrop()">DROP TOKENS</button>
            <button id="btn-start-round" class="btn-play hidden" onclick="closeCoinModal()">START ROUND</button>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 40px; color: var(--highlight);">CYBER STACK</h1>
        <div style="color: var(--warning); font-size: 14px; margin-bottom: 20px;">// v4.8 BALANCED //</div>
        
        <div class="selection-group">
            <div>HUMAN PLAYERS</div>
            <button class="sel-btn active" onclick="setSetup('p', 1)">1</button><button class="sel-btn" onclick="setSetup('p', 2)">2</button><button class="sel-btn" onclick="setSetup('p', 3)">3</button><button class="sel-btn" onclick="setSetup('p', 4)">4</button>
        </div>
        
        <div class="selection-group">
            <div>CPU OPPONENTS</div>
            <button class="sel-btn" onclick="setSetup('b', 0)">0</button><button class="sel-btn active" onclick="setSetup('b', 1)">1</button><button class="sel-btn" onclick="setSetup('b', 2)">2</button><button class="sel-btn" onclick="setSetup('b', 3)">3</button>
        </div>
        
        <div class="selection-group" style="margin-top: 15px;">
            <div style="margin-bottom: 10px;">CUSTOM TOKENS (Per Match)</div>
            <div style="display: flex; gap: 15px; justify-content: center; align-items: center;">
                <div>R1: <input type="number" id="token-r1" class="token-input" value="2" min="1" max="50"></div>
                <div>R2: <input type="number" id="token-r2" class="token-input" value="4" min="1" max="50"></div>
                <div>R3: <input type="number" id="token-r3" class="token-input" value="6" min="1" max="50"></div>
            </div>
        </div>
        
        <button class="btn-play" style="margin-top:25px; width: 200px;" onclick="startGame()">INITIALIZE</button>
    </div>

    <div id="discard-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2>DISCARD PILE</h2><button class="btn-pass" onclick="toggleDiscard()">CLOSE</button>
            <div id="discard-grid" class="modal-grid"></div>
        </div>
    </div>
    
    <div id="select-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="select-title">TARGET</h2>
            <div id="select-status"></div>
            <div id="select-grid" class="modal-grid"></div>
        </div>
    </div>
    
    <div id="stats-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2>STATS</h2><button class="btn-pass" onclick="toggleStats()">CLOSE</button>
            <div id="stats-container"></div>
        </div>
    </div>

    <div id="game-root" class="game-container hidden">
        <div style="display:flex; justify-content:center; width:100%; margin-bottom:10px;">
            <div class="pot-display">
                <span style="color:#888;">STAKES:</span>
                <span id="pot-points" style="color:var(--success);">‚≠ê 0</span>
                <span>|</span>
                <span id="pot-finisher" style="color:var(--highlight);">üé® 0</span>
            </div>
        </div>

        <div id="opponents" class="opponent-area"></div>

        <div class="controls">
            <div id="dice-display" class="dice-box">?</div>
            <div class="overclock-panel">
                <div>OVERCLOCK</div><div style="font-size:10px; color:#888;">Right-Click</div>
                <div id="bonus-display" style="font-size:18px; color:#fe9;">+0</div>
            </div>
            <div class="btn-group">
                <button id="btn-roll" class="btn-play" onclick="commitTurn()">CONFIRM MOVE</button>
                <button id="btn-pass" class="btn-pass" onclick="passTurn()">REBOOT</button>
                <button id="btn-disc" class="btn-discard" onclick="toggleDiscard()">DISCARD</button>
                <button id="btn-stats" class="btn-stats" onclick="toggleStats()">STATS</button>
            </div>
            <div style="text-align:left; font-size:12px;">
                <div>TURN: <span id="turn-display">1</span></div>
                <div>PHASE: <span id="phase-display" style="color:var(--highlight)">PLANNING</span></div>
            </div>
        </div>

        <div class="player-area" id="player-main-area">
            <div id="active-player-name" class="turn-indicator">PLAYER 1</div>
            <div class="info-panel">
                <div>SCORE: <span id="player-score" style="color:var(--success);">0 VP</span> <span id="total-score-display" style="color:#888;">(0)</span> <span id="player-tokens" style="color:#d29922;">ü™ô 0</span></div>
                <div><span id="hand-count">Hand: 0/5</span> | <span id="colors-status">Colors: 0/5</span></div>
            </div>
            <div id="player-score-pile" class="card-zone"></div>
            <div id="player-hand" class="card-zone"></div>
        </div>

        <div id="game-log"></div>
    </div>

<script>
/* --- CONFIGURATION --- */
const COLORS = ["Red", "Blue", "Green", "Yellow", "Purple"];
const STARTING_HAND = 3; 
const MAX_HAND = 5; 
const TRIGGER_COLORS = 5; 
const TOTAL_ROUNDS = 3;

/* --- STATE VARIABLES --- */
let deck = [], discardPile = [], players = [];
let turnCount = 1, currentRound = 1, activePlayerIdx = 0;
let setupP = 1, setupB = 1; 
let tokenProgression = [2, 4, 6]; 
let pauseForInteraction = false;
let cardStats = {};
let matchPot = { points: 2, finisher: 2 };

/* --- CLASSES --- */
class Card {
    constructor(s1, s2) {
        this.id = Math.random().toString(36).substr(2,9);
        this.sides = [s1, s2];
        this.selectedSide = 0; 
        this.isBurning = false; 
    }
}

class Player {
    constructor(name, isBot) {
        this.name = name;
        this.isBot = isBot;
        this.hand = [];
        this.scorePile = [];
        this.cache = [];
        this.passed = false;
        this.selection = null; 
        this.bonus = 0;
        this.totalScore = 0;
        this.tokens = 0; 
    }
    getRoundScore() {
        let s = 0;
        this.scorePile.forEach(c => s += c.sides[c.selectedSide].value);
        this.cache.forEach(c => s += c.sides[c.selectedSide].value);
        return s;
    }
    getUniqueColors() {
        let s = new Set(), w = 0;
        this.scorePile.forEach(c => { 
            let side = c.sides[c.selectedSide];
            if(side.type==='Color') s.add(side.name); 
            if(side.type==='Wild') w++; 
        });
        return Math.min(TRIGGER_COLORS, s.size + w); 
    }
    resetForRound() {
        this.hand = []; this.scorePile = []; this.cache = [];
        this.passed = false; this.selection = null; this.bonus = 0;
    }
}

/* --- INITIALIZATION --- */
function setSetup(t, v) {
    if(t==='p') setupP=v; 
    if(t==='b') setupB=v; 
    
    let g = t==='p' ? 0 : 1; 
    let btns = document.querySelectorAll('.selection-group')[g].querySelectorAll('.sel-btn');
    
    btns.forEach(b => b.classList.remove('active')); 
    
    btns.forEach(b => { 
        if(parseInt(b.innerText) === v) b.classList.add('active'); 
    });
}

function startGame() {
    tokenProgression[0] = parseInt(document.getElementById('token-r1').value) || 2;
    tokenProgression[1] = parseInt(document.getElementById('token-r2').value) || 4;
    tokenProgression[2] = parseInt(document.getElementById('token-r3').value) || 6;

    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-root').classList.remove('hidden');
    
    players = [];
    for(let i=1; i<=setupP; i++) players.push(new Player(`PLAYER ${i}`, false));
    for(let i=1; i<=setupB; i++) players.push(new Player(`CPU ${i}`, true));
    
    currentRound = 1; cardStats = {}; 
    startNewRound();
}

function startNewRound() {
    turnCount = 1; deck = generateDeck(); discardPile = [];
    players.forEach(p => { p.resetForRound(); drawCards(p, STARTING_HAND); });
    document.getElementById('turn-display').innerText = currentRound;
    openCoinModal();
}

/* --- TOKEN DROP SYSTEM --- */
function openCoinModal() {
    let modal = document.getElementById('coin-modal'), area = document.getElementById('coin-area');
    
    let tokenCount = tokenProgression[currentRound - 1] || 2; 
    
    document.getElementById('token-subtitle').innerHTML = `Flipping ${tokenCount} Tokens...<br>‚≠ê = Most Points | üé® = First to 5 Colors`;
    
    area.innerHTML = ''; document.getElementById('coin-result').innerText = '';
    document.getElementById('btn-drop').classList.remove('hidden');
    document.getElementById('btn-start-round').classList.add('hidden');
    
    for(let i=0; i<tokenCount; i++) {
        let c = document.createElement('div'); c.className = 'coin';
        c.innerHTML = `<div class="coin-face face-heads">‚≠ê</div><div class="coin-face face-tails">üé®</div>`;
        area.appendChild(c);
    }
    modal.classList.remove('hidden');
}

function executeCoinDrop() {
    let coins = document.querySelectorAll('.coin'); 
    matchPot = { points: 0, finisher: 0 };
    coins.forEach(c => {
        let h = Math.random() > 0.5;
        let rot = h ? 0 : 180;
        let extra = 720 + (Math.floor(Math.random()*3)*360);
        c.style.transform = `rotateY(${rot + extra}deg)`; 
        if(h) matchPot.points++; else matchPot.finisher++;
    });
    document.getElementById('btn-drop').classList.add('hidden');
    setTimeout(() => {
        document.getElementById('coin-result').innerText = `RESULT: ${matchPot.points} PTS | ${matchPot.finisher} FINISHER`;
        document.getElementById('btn-start-round').classList.remove('hidden');
    }, 1200);
}

function closeCoinModal() {
    document.getElementById('coin-modal').classList.add('hidden');
    log(`=== ROUND ${currentRound} START === POT: ${matchPot.points}‚≠ê / ${matchPot.finisher}üé®`);
    activePlayerIdx = 0; updateUI();
}

/* --- DECK GENERATION --- */
function generateDeck() {
    let d = [];
    for(let i=0; i<COLORS.length; i++) for(let j=i+1; j<COLORS.length; j++) {
        d.push(new Card({name:COLORS[i], type:'Color', target:5, value:3}, {name:COLORS[j], type:'Color', target:3, value:1}));
        d.push(new Card({name:COLORS[i], type:'Color', target:4, value:2}, {name:COLORS[j], type:'Color', target:4, value:2}));
        d.push(new Card({name:COLORS[i], type:'Color', target:3, value:1}, {name:COLORS[j], type:'Color', target:5, value:3}));
    }
    COLORS.forEach(c => d.push(new Card({name:'Wild', type:'Wild', target:6, value:4}, {name:c, type:'Color', target:2, value:0})));
    
    // UPDATED ACTION PAIRINGS
    for(let i=0; i<4; i++) d.push(new Card({name:'Draw +2', type:'Action', effect:'Draw +2', target:4, value:0}, {name:'Flip', type:'Action', effect:'Flip', target:4, value:0}));
    for(let i=0; i<4; i++) d.push(new Card({name:'Steal', type:'Action', effect:'Steal', target:4, value:0}, {name:'Draw +1', type:'Action', effect:'Draw +1', target:2, value:0}));
    
    return shuffle(d);
}
function shuffle(a) { for(let i=a.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function drawCards(p, n) {
    for(let i=0; i<n; i++) {
        if(deck.length===0 && discardPile.length>0) { deck = shuffle([...discardPile]); discardPile = []; }
        if(deck.length>0) { if(p.hand.length<MAX_HAND) p.hand.push(deck.pop()); else discardPile.push(deck.pop()); }
    }
}

/* --- GAME TURN LOGIC --- */
function passTurn() {
    let p = players[activePlayerIdx]; 
    p.passed = true; p.selection = null; p.bonus = 0;
    p.hand.forEach(c => c.isBurning = false); 
    log(`${p.name} PASSES.`); 
    advanceQueue();
}

function commitTurn() {
    let p = players[activePlayerIdx];
    if(!p.selection) { alert("Select a card!"); return; }
    p.bonus = 0; let fh = [];
    p.hand.forEach(c => { 
        if(c.isBurning) { discardPile.push(c); p.bonus++; } 
        else fh.push(c); 
    });
    p.hand = fh;
    if(!p.hand.includes(p.selection.card)) { p.passed = true; p.selection = null; }
    
    // Clear the player's UI immediately to make room for the animation
    document.getElementById('player-hand').innerHTML = '';
    
    advanceQueue();
}

function advanceQueue() {
    activePlayerIdx++;
    if(activePlayerIdx < players.length && !players[activePlayerIdx].isBot) {
        updateUI();
    } else { 
        processBots(); 
        triggerDiceRoll(); 
    }
}

function triggerDiceRoll() {
    let overlay = document.getElementById('dice-overlay'), cube = document.getElementById('dice-cube');
    cube.style.transition = 'none'; cube.style.transform = 'rotateX(0deg) rotateY(0deg)';
    void cube.offsetWidth; overlay.classList.remove('hidden');
    
    let roll = Math.floor(Math.random()*6)+1;
    setTimeout(() => {
        cube.style.transition = 'transform 1.2s cubic-bezier(0.1,0.7,0.1,1)';
        let rx = 720 + (roll===2?-90:roll===5?90:0);
        let ry = 720 + (roll===6?180:roll===3?-90:roll===4?90:0);
        cube.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`;
    }, 50);
    
    setTimeout(() => { 
        overlay.classList.add('hidden'); 
        executeRound(roll); 
    }, 1500);
}

function executeRound(roll) {
    document.getElementById('dice-display').innerText = roll;
    log(`--- TURN ${turnCount} | ROLL: ${roll} ---`, true);
    
    pauseForInteraction = false;
    
    try {
        players.filter(p=>p.isBot).forEach(p=>resolvePlayer(p, roll));
        players.filter(p=>!p.isBot).forEach(p=>resolvePlayer(p, roll));
    } catch(e) { console.error("Error in Execution:", e); }

    if(!pauseForInteraction) {
        // INCREASED TIMEOUT: Gives cards time to animate before UI resets
        setTimeout(finishTurnSequence, 3000); 
    } else {
        document.getElementById('phase-display').innerText = "WAITING FOR PLAYER...";
    }
}

/* --- NEW ANIMATION LOGIC --- */
function spawnFloatingCard(p, card, sIdx, isSuccess) {
    let pId = p === players[0] ? 'player-main-area' : `hud-p${players.indexOf(p)}`;
    let pEl = document.getElementById(pId);
    if (!pEl) return;

    let rect = pEl.getBoundingClientRect();
    
    let floatingCard = document.createElement('div');
    floatingCard.className = 'card floating-card';
    floatingCard.style.position = 'fixed';
    
    // Start at the player's UI
    floatingCard.style.left = rect.left + (rect.width / 2) - 50 + 'px';
    floatingCard.style.top = rect.top + 'px';
    floatingCard.style.transition = 'all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1)';
    
    let s = card.sides[sIdx];
    floatingCard.innerHTML = `<div class="card-side active type-${getTypeClass(s)}" style="height:100%"><b>${s.name}</b><br>T${s.target} ‚Ä¢ ${s.value}VP</div>`;
    
    document.body.appendChild(floatingCard);
    
    // Stage 1: Fly to center and fan out slightly to read
    setTimeout(() => {
        let xOffset = (Math.random() * 80) - 40;
        let yOffset = (Math.random() * 40) - 20;
        floatingCard.style.left = (window.innerWidth / 2) - 50 + xOffset + 'px';
        floatingCard.style.top = (window.innerHeight / 2) - 100 + yOffset + 'px';
        floatingCard.style.transform = 'scale(1.3) rotate(' + ((Math.random()*10)-5) + 'deg)';
        floatingCard.style.boxShadow = isSuccess ? '0 0 25px var(--success)' : '0 0 25px var(--danger)';
        floatingCard.style.border = isSuccess ? '2px solid var(--success)' : '2px solid var(--danger)';
    }, 50);

    // Stage 2: Fly to destination (Discard or Score Pile)
    setTimeout(() => {
        let destId = isSuccess ? (p === players[0] ? 'player-score-pile' : pId) : 'btn-disc';
        let destEl = document.getElementById(destId);
        if(destEl) {
            let dRect = destEl.getBoundingClientRect();
            floatingCard.style.transition = 'all 0.5s ease-in';
            floatingCard.style.left = dRect.left + (dRect.width/2) - 50 + 'px';
            floatingCard.style.top = dRect.top + 'px';
            floatingCard.style.transform = 'scale(0.3)';
            floatingCard.style.opacity = '0';
        }
    }, 1800);

    // Stage 3: Cleanup Element
    setTimeout(() => {
        floatingCard.remove();
    }, 2400);
}

function finishTurnSequence() {
    document.getElementById('phase-display').innerText = "PLANNING";
    let f = players.find(p => p.getUniqueColors() >= TRIGGER_COLORS);
    
    if(f) {
        endRound(f);
    } else {
        players.forEach(p => { 
            drawCards(p,1); 
            p.selection=null; 
            p.passed=false; 
            p.bonus=0; 
            p.hand.forEach(c=>c.isBurning=false); 
        });
        activePlayerIdx = 0; 
        turnCount++; 
        updateUI();
    }
}

function resolvePlayer(p, roll) {
    if(p.passed || !p.selection) return;
    let card = p.selection.card, sIdx = p.selection.sideIndex, side = card.sides[sIdx];
    let total = roll + p.bonus;
    
    let hIdx = p.hand.indexOf(card); 
    if(hIdx>-1) p.hand.splice(hIdx,1);

    let key = side.name; if(!cardStats[key]) cardStats[key]={played:0,success:0,fail:0};
    cardStats[key].played++;

    if(total >= side.target) {
        log(`${p.name} Success: ${side.name}`, false, 'success');
        cardStats[key].success++; 
        
        spawnFloatingCard(p, card, sIdx, true); // TRIGGER SUCCESS ANIMATION
        triggerVisualFX('success', p);
        
        card.selectedSide = sIdx;
        
        if(side.effect === 'Draw +2') { 
            drawCards(p, 2); log(`> Draw +2 executed!`); discardPile.push(card); 
        }
        else if (side.effect === 'Draw +1') {
            drawCards(p, 1); log(`> Draw +1 executed!`); discardPile.push(card); 
        }
        else if(side.effect === 'Steal') {
            discardPile.push(card);
            if(!p.isBot) { 
                pauseForInteraction = true; 
                openPlayerSelectUI(p, 'STEAL'); 
            } else { 
                handleBotSteal(p); 
            }
        }
        else if(side.effect === 'Flip') {
            discardPile.push(card);
            if(!p.isBot) { 
                pauseForInteraction = true; 
                openPlayerSelectUI(p, 'FLIP'); 
            } else { 
                handleBotFlip(p); 
            }
        }
        else if(side.type === 'Point') { 
            p.cache.push(card); 
        }
        else { 
            p.scorePile.push(card); 
        }
    } else {
        log(`${p.name} Fails ${side.name}`, false, 'fail');
        cardStats[key].fail++; 
        
        spawnFloatingCard(p, card, sIdx, false); // TRIGGER FAILURE ANIMATION
        triggerVisualFX('fail', p); 
        
        discardPile.push(card);
    }
}

/* --- UI & INTERACTION --- */
function triggerVisualFX(type, p) {
    let id = (p===players[0]) ? 'player-main-area' : `hud-p${players.indexOf(p)}`;
    let el = document.getElementById(id); if(!el) return;
    
    let box = document.createElement('div');
    box.style.position="absolute"; box.style.top="50%"; box.style.left="50%"; 
    box.style.transform="translate(-50%,-50%)"; box.style.zIndex="100"; box.style.pointerEvents="none";
    
    let txt = document.createElement('div');
    txt.className = `fx-text ${type==='success'?'fx-success':'fx-fail'}`;
    txt.innerText = type==='success'?"SUCCESS":"FAILURE";
    
    if(p!==players[0]) { txt.style.fontSize="20px"; txt.style.padding="5px"; } 
    else txt.style.fontSize="60px";
    
    box.appendChild(txt); el.appendChild(box);
    if(type==='fail') { el.classList.add('element-shake'); setTimeout(()=>el.classList.remove('element-shake'),500); }
    setTimeout(()=>box.remove(), 2000);
}

function openPlayerSelectUI(player, mode) {
    let modal = document.getElementById('select-modal'), grid = document.getElementById('select-grid');
    document.getElementById('select-title').innerText = mode==='STEAL'?"STEAL FROM...":"FLIP WHO?";
    
    let status = document.getElementById('select-status');
    let myCards = "";
    player.scorePile.forEach(c => {
        let s = c.sides[c.selectedSide];
        let bColor = s.type === 'Color' ? s.name.toLowerCase() : '#444';
        myCards += `<div class="mini-card" style="width:auto; padding:4px 8px; border-color:${bColor}; color:white;">${s.name} (${s.value}VP)</div>`;
    });
    
    status.innerHTML = `<div style="margin-bottom: 20px; background: #0d1117; padding: 15px; border-radius: 6px; border: 1px solid var(--highlight);">
                            <div style="font-size: 14px; color: var(--highlight); margin-bottom: 10px; font-weight:bold;">YOUR CURRENT CARDS (Colors: ${player.getUniqueColors()}/${TRIGGER_COLORS})</div>
                            <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">${myCards || '<span style="color:#555">No cards scored yet.</span>'}</div>
                        </div>`;
    
    grid.innerHTML = "";
    
    let targets = players.filter(v => v.scorePile.length > 0);
    if(mode==='STEAL') targets = targets.filter(v => v !== player);
    
    if(targets.length === 0) { 
        log(`> No valid targets.`); 
        modal.classList.add('hidden'); 
        pauseForInteraction=false; 
        
        // Ensure UI resets normally if interaction canceled
        setTimeout(finishTurnSequence, 3000); 
        return; 
    }
    
    modal.classList.remove('hidden');
    
    let container = document.getElementById('select-modal').querySelector('.modal-content');
    let old = container.querySelector('.back-btn'); if(old) old.remove();

    targets.forEach(v => {
        let b = document.createElement('div'); b.className = 'target-btn';
        b.innerHTML = `<b>${v.name}</b><br>${v.scorePile.length} Cards`;
        b.onclick = () => { if(mode==='STEAL') showStealCards(player,v); else showFlipCards(player,v); };
        grid.appendChild(b);
    });
}

function showStealCards(player, victim) {
    let grid = document.getElementById('select-grid'); grid.innerHTML = '';
    addBackBtn(player, 'STEAL');
    
    victim.scorePile.forEach((c, i) => {
        let s = c.sides[c.selectedSide];
        let el = document.createElement('div'); el.className = 'card';
        el.innerHTML = `<div class="card-side active type-${getTypeClass(s)}" style="height:100%"><span class="side-title">${s.name}</span><br>${s.value} VP</div>`;
        el.onclick = () => {
            victim.scorePile.splice(i,1); player.scorePile.push(c);
            log(`> Stole ${s.name}!`, false, 'success');
            document.getElementById('select-modal').classList.add('hidden'); 
            pauseForInteraction = false; 
            finishTurnSequence();
        };
        grid.appendChild(el);
    });
}

function showFlipCards(player, target) {
    let grid = document.getElementById('select-grid'); grid.innerHTML = '';
    addBackBtn(player, 'FLIP');
    
    target.scorePile.forEach((c, i) => {
        let s = c.sides[c.selectedSide], o = c.sides[c.selectedSide === 0 ? 1 : 0];
        let el = document.createElement('div'); el.className = 'card';
        el.innerHTML = `<div class="card-side active type-${getTypeClass(s)}"><span>${s.name}</span><br>${s.value}VP</div><div style="text-align:center">‚¨á</div><div class="card-side inactive type-${getTypeClass(o)}"><span>${o.name}</span><br>${o.value}VP</div>`;
        el.onclick = () => {
            c.selectedSide = c.selectedSide === 0 ? 1 : 0;
            log(`> Flipped ${target.name}'s card!`, false, 'success');
            document.getElementById('select-modal').classList.add('hidden'); 
            pauseForInteraction = false;
            finishTurnSequence();
        };
        grid.appendChild(el);
    });
}

function addBackBtn(player, mode) {
    let container = document.getElementById('select-modal').querySelector('.modal-content');
    let old = container.querySelector('.back-btn'); if(old) old.remove();
    let b = document.createElement('div'); b.className = 'back-btn'; b.innerText = "‚¨Ö GO BACK";
    b.onclick = () => openPlayerSelectUI(player, mode);
    container.insertBefore(b, document.getElementById('select-grid'));
}

/* BOT LOGIC */
function processBots() {
    players.filter(p => p.isBot).forEach(p => {
        if (p.hand.length > 0) {
            let cIdx = Math.floor(Math.random() * p.hand.length);
            let sIdx = Math.floor(Math.random() * 2);
            p.selection = { card: p.hand[cIdx], sideIndex: sIdx };
        } else {
            p.passed = true;
        }
    });
}

function renderStats() {
    let container = document.getElementById('stats-container');
    if (Object.keys(cardStats).length === 0) {
        container.innerHTML = "<p>No data yet. Play some cards!</p>";
        return;
    }
    let html = "<table style='width:100%; text-align:left; border-collapse:collapse; margin-top:10px;'>";
    html += "<tr style='border-bottom:1px solid #555'><th>Card</th><th>Played</th><th>Success</th><th>Fail</th></tr>";
    for (let [key, stat] of Object.entries(cardStats)) {
        html += `<tr><td>${key}</td><td>${stat.played}</td><td style='color:var(--success)'>${stat.success}</td><td style='color:var(--danger)'>${stat.fail}</td></tr>`;
    }
    html += "</table>";
    container.innerHTML = html;
}

function handleBotSteal(att) {
    try {
        let t = players.filter(p => p !== att && p.scorePile.length > 0);
        if(t.length) { 
            let v = t.sort((a,b) => b.getRoundScore() - a.getRoundScore())[0]; 
            v.scorePile.sort((a,b) => b.sides[b.selectedSide].value - a.sides[a.selectedSide].value);
            let c = v.scorePile.shift(); 
            att.scorePile.push(c); 
            log(`> ${att.name} stole from ${v.name}`); 
        }
    } catch(e) { console.log("Bot Steal Error", e); }
}

function handleBotFlip(att) {
    try {
        let t = players.filter(p => p !== att && p.scorePile.length > 0);
        if(t.length) { 
            let v = t.sort((a,b) => b.getRoundScore() - a.getRoundScore())[0]; 
            v.scorePile.sort((a,b) => b.sides[b.selectedSide].value - a.sides[a.selectedSide].value);
            let c = v.scorePile[0]; 
            c.selectedSide = c.selectedSide === 0 ? 1 : 0; 
            log(`> ${att.name} flipped ${v.name}'s card!`); 
        }
    } catch(e) { console.log("Bot Flip Error", e); }
}

function endRound(finisher) {
    let sorted = [...players].sort((a,b)=>b.getRoundScore()-a.getRoundScore());
    let winner = sorted[0];

    if (finisher) finisher.tokens += matchPot.finisher;
    winner.tokens += matchPot.points;

    players.forEach(p => { p.totalScore += p.getRoundScore(); });

    let msg = `ROUND ${currentRound} COMPLETE!\n\n`;
    if(finisher) msg += `üèÜ ROUND ENDER: ${finisher.name} (+${matchPot.finisher} Tokens)\n`;
    msg += `‚≠ê HIGH SCORE: ${winner.name} (+${matchPot.points} Tokens)\n\nSCORES:\n`;
    players.forEach(p => { msg += `${p.name}: ${p.getRoundScore()} VP | Tokens: ${p.tokens} | Total VP: ${p.totalScore}\n`; });
    
    alert(msg);
    if (currentRound < TOTAL_ROUNDS) { currentRound++; startNewRound(); } else endGame();
}

function endGame() {
    let sorted = [...players].sort((a,b)=>b.totalScore-a.totalScore);
    let winner = sorted[0];
    let summary = "";
    sorted.forEach(p => summary += `${p.name}: ${p.totalScore} VP | ${p.tokens} Tokens\n`);
    alert(`TOURNAMENT OVER!\n\nWINNER: ${winner.name}\n\n${summary}`);
    location.reload();
}

/* UTILS */
function selectSide(c,s) { if(!players[0].hand[c].isBurning) { players[0].selection={card:players[0].hand[c], sideIndex:s}; updateUI(); } }
function toggleBurn(c) { players[0].hand[c].isBurning = !players[0].hand[c].isBurning; players[0].bonus=players[0].hand.filter(x=>x.isBurning).length; updateUI(); }
function toggleDiscard() { document.getElementById('discard-modal').classList.toggle('hidden'); if(!document.getElementById('discard-modal').classList.contains('hidden')) { let g=document.getElementById('discard-grid'); g.innerHTML=''; discardPile.forEach(c=>g.appendChild(createCardElement(c,true,-1,true))); } }
function toggleStats() { document.getElementById('stats-modal').classList.toggle('hidden'); if(!document.getElementById('stats-modal').classList.contains('hidden')) renderStats(); }

function updateUI() {
    let p = players[0];
    document.getElementById('btn-roll').innerText = (activePlayerIdx===0) ? "CONFIRM MOVE" : "WAITING...";
    document.getElementById('btn-roll').disabled = (activePlayerIdx!==0 || !p.selection);
    document.getElementById('player-score').innerText = `${p.getRoundScore()} VP`;
    document.getElementById('player-tokens').innerText = `ü™ô ${p.tokens}`;
    document.getElementById('pot-points').innerText = `‚≠ê ${matchPot.points}`;
    document.getElementById('pot-finisher').innerText = `üé® ${matchPot.finisher}`;
    document.getElementById('bonus-display').innerText = `+${p.bonus}`;
    
    document.getElementById('colors-status').innerText = `Colors: ${p.getUniqueColors()}/${TRIGGER_COLORS}`;
    document.getElementById('hand-count').innerText = `Hand: ${p.hand.length}/${MAX_HAND}`;
    document.getElementById('btn-disc').innerText = `DISCARD (${discardPile.length})`;

    let hd = document.getElementById('player-hand'); hd.innerHTML='';
    p.hand.forEach((c,i) => { let el=createCardElement(c,true,i); hd.appendChild(el); });
    
    let pd = document.getElementById('player-score-pile'); pd.innerHTML='';
    p.scorePile.forEach(c => pd.appendChild(createCardElement(c,false)));
    
    let od = document.getElementById('opponents'); od.innerHTML='';
    players.forEach((opp,i) => { if(i!==0) od.appendChild(createOpponentHUD(opp)); });
}

function createCardElement(card, interact, idx, isDisc=false) {
    let el = document.createElement('div'); el.className = 'card'; if(card.isBurning) el.classList.add('burning');
    let s0=card.sides[0], s1=card.sides[1];
    
    if(interact || isDisc) {
        let sel = (players[0] && players[0].selection && players[0].selection.card===card);
        el.innerHTML = `
            <div class="card-side type-${getTypeClass(s0)} ${sel && players[0].selection.sideIndex===0?'active':''}" onclick="${isDisc ? '' : `selectSide(${idx},0)`}"><b>${s0.name}</b><br>T${s0.target} ‚Ä¢ ${s0.value}VP</div>
            <div style="font-size:10px;text-align:center">-</div>
            <div class="card-side type-${getTypeClass(s1)} ${sel && players[0].selection.sideIndex===1?'active':''}" onclick="${isDisc ? '' : `selectSide(${idx},1)`}"><b>${s1.name}</b><br>T${s1.target} ‚Ä¢ ${s1.value}VP</div>
        `;
        el.setAttribute('data-tooltip', `${s0.name} (T${s0.target} / ${s0.value}VP) \n ${s1.name} (T${s1.target} / ${s1.value}VP)`);
        
        if (!isDisc) {
            el.oncontextmenu=(e)=>{e.preventDefault(); toggleBurn(idx);};
        }
    } else {
        let s = card.sides[card.selectedSide];
        el.innerHTML = `<div class="card-side active type-${getTypeClass(s)}" style="height:100%"><b>${s.name}</b><br>${s.value}VP</div>`;
    }
    return el;
}

function createOpponentHUD(p) {
    let div = document.createElement('div'); div.className='player-hud'; div.id=`hud-p${players.indexOf(p)}`;
    let h = `<div class="hud-header"><span>${p.name}</span><span>${p.getRoundScore()} VP</span></div>
             <div class="hud-stats">Tokens: ${p.tokens} | Hand: ${p.hand.length}</div>
             <div style="margin-top:5px;display:flex;flex-wrap:wrap">`;
    p.scorePile.forEach(c=>{ 
        let s=c.sides[c.selectedSide]; 
        let bColor = s.type === 'Color' ? s.name.toLowerCase() : '#444';
        h+=`<div class="mini-card" style="border-color:${bColor}">${s.name[0]}</div>`
    });
    div.innerHTML = h + `</div>`; return div;
}

function getTypeClass(s) { 
    if (s.type === 'Color') return s.name.toLowerCase();
    return (s.type==='Wild'?'wild':(s.type==='Action'?'action':'gray')); 
}

function getValStr(s) { return s.effect ? s.effect : s.value + " VP"; }
function hasColor(p, name) { return p.scorePile.some(c => c.sides[c.selectedSide].name === name); }
function log(m,head,type) {
    let d=document.getElementById('game-log'), e=document.createElement('div');
    e.className=head?'log-turn':'log-entry'; if(type) e.classList.add(`log-${type}`);
    e.innerText=m; d.prepend(e);
}
</script>
</body>
</html>